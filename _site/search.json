[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Semester Goals for E155\n\n\nThese are my initial thoughts on the course and what I hope to gain out of it\n\n\n\n\n\nAug 29, 2025\n\n\nChristian Wu\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Christian Wu is a Junior at Harvey Mudd College studying Engineering, with an passion for digital electronics and hardware engineering. Christian grew up in Santiago, Chile, until he moved to the United States to attend Harvey Mudd College. His professional experience includes being a manufacturing engineering intern at Johnson & Johnson and General Motors. Christian is a Machine Shop Proctor at Harvey Mudd and enjoys playing basketball in his time off.\nThis portofolio will highlight the work done over the course of the semester in E155: Microprocessor Based Systems"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Semester Goals for E155",
    "section": "",
    "text": "I took this course for a few reasons. First, I think that Hardware Engineering is a future career path for me, and something that I want to pursue long term. It is a good intersection between challenging problem solving that can impact billions of people around the world and my passion for electronics and computing. When I took E85 last year with Prof. Harris, I really enjoyed working on the labs, while sometimes challenging, it was really rewarding to see a project of mine come to fruition. I’ve chosen to take this course in my Junior year, in hopes that it will open up opportunities for internships in Hardware Engineeering. I would like to use my last summer of internships to be able to decide what career I would like to pursue after graduating from Mudd next year.\nThis semester, I would like to be able to absorb as much knowledge as I can, learning new techniques and ways to deal with software and hwardware. I think the nature of this class and the difficulty associated with it will also push me to learn some intangible skills that can be applied in my post-Mudd life. The tenacity and perseverance through challenging labs that aren’t going my way, and the ability to work more efficiently and under a time constraint to complete the labs on time every week will be valuable to being able to meet deadlines and tackle challenging real world problems in the industry.\nI look forward to a great semester of learning!"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "The goal of this lab is to read a 4 x 4 matrix keypad and display the last two digits on a dual 7-segment display, with the most recent entry appearing on the right. Each key press should only register once, and additional key inputs when a button is held down should be ignored."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "The goal of this lab is to read a 4 x 4 matrix keypad and display the last two digits on a dual 7-segment display, with the most recent entry appearing on the right. Each key press should only register once, and additional key inputs when a button is held down should be ignored."
  },
  {
    "objectID": "labs/lab3/lab3.html#fpga-design",
    "href": "labs/lab3/lab3.html#fpga-design",
    "title": "Lab 3: Keypad Scanner",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nObjective\nThe objective of this lab is to build upon the work done in Lab 2, by adding the addition of a keypad for inputs. This brings an additional layer of complexity, by making sure that we synchronize asynchronous outputs, eliminate switch bouncing, and making sure that buttons are only registered once.\n\n\nDesign\n\nSynchronizing asynchronous inputs\nMetastability occurs with this keypad when key inputs occur too close to a rising edge of the clock, causing asynchrony. To fix this, we can use a two stage synchronizer, which involves using two flip flops to synchronize our keypad input and have a stable input going into the FSM. This is done in this lab by synchronizing my column inputs, with the synchronizer module.\n\n\nAccounting for switch bouncing\nAll mechanical switches have a phenomenom called switch bouncing, where the input signals by the switch oscillate quickly between on and off as the button is getting clicked. This occurs until the button is fully clicked and the input signal becomes stable. To account for this and not read mistake one key press for multiple key presses, I used SystemVerilog code to add a delay between reading inputs in my FSM. This will prevent a single key input being mistaken as multiple inputs.\n\n\nBlock Diagram\nMy approach to this lab consists of eight different modules. It was designed to have many modules to make testing the functionality of each function of this lab easily. An overarching top level module called lab3_cw, which will be programmed to the board, and seven submodules synchronizer, keypadFSM, keypad, sevenSegDigits, timeMultiplexer, sevenSegMux and sevenSegDisplay. The synchronizer submodule will synchronize my keypad inputs using a simple two stage synchronizer with two flip flops. The keypadFSM submodule is an FSM that controls how to detect keypad presses and what to do with it. It also implements switch debouncing. The keypad submodule helps decode what number corresponds to each row and column on the 4 x 4 keypad. The sevenSegDigits submodule is responsible for shifting the digits on the dual 7-segment display based on what the FSM tells it to do. The timeMultiplexer submodule is the same as in lab 2, and is responsible for controlling which common anode gets turned on in the dual 7-segment display. The sevenSegMux submodule is the same as in lab 2, and is a mux that controls which four bit input will be fed into sevenSegmentDisplay based on the enable, signal, which is given by timeMultiplexer. The sevenSegmentDisplay submodule is the same one that was used in Lab 1 and 2, which will control the outputs on the 7-segment display, displaying the hexadecimal value provided by the dip switches, s1[3:0] and s2[3:0]. It was designed to switch at 500 Hz, which should be high enough to not be noticeable to the human eye. It will also output a signal to guide which input should be used by the sevenSegmentDisplay module, which is controlled by sevenSegMux. The top level lab3_cw calls upon all these submodules as well as the HSOSC submodule, which takes advantage of the onboard 48 MHz clock on the FPGA. Below is the block diagram I used to create this project:\n\n\n\nLab 3 Block Diagram\n\n\n\n\nsynchronizer Design\nThe synchronizer submodule was a very simple design. It consisted of a two stage synchronizer by utilizing two flip flops to synchronize our asynchronous inputs.\nBelow is the code block that was used for this submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/13/25\n\n// This module is a simple two-stage synchronizer to safely bring an asynchronous input signal\n// into the clock domain of the provided clock signal. This helps to prevent metastability issues.\n\nmodule synchronizer (\n    input logic clk,\n    input logic reset,\n    input logic [3:0] in,\n    output logic [3:0] out);\n\n    logic [3:0] mid;\n\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            mid &lt;= 4'b0000;\n            out &lt;= 4'b0000;\n        end else begin\n        mid &lt;= in;\n        out &lt;= mid;\n    end\n    end\nendmodule\n\n\nKeypad FSM Design\nThe FSM was designed to have 12 states. In order to detect key presses, I would rotate between scanning each row, one at a time until detecting a key input. Then it would move into the debounce state where it would have a 50 ms delay for debouncing, and then go to the hold state if the input is stable.\nSome mechanical switches only bounce for 10 - 20 ms, so my debouncing method accounts for all of it and makes sure that keys are debounced. However, tradeoffs for this is that responses might be slow due to the long debounce time and the slow time between moving state to state, which goes at 1 kHz. But for the purposes of this lab, it seems pretty reasonable to go at 50 ms, since we cannot really exploit the long debounce times as it is not noticeable to the human eye and reaction speed. Another limitation is the need for an extra four states for debouncing. Right now, I am utilizing 4 bits of state, while only using 12 states, so I am wasting 4 states. If I did not have 4 bits of debouncing state, I could use just 3 bits of state and fully utilize it.\nHere is my FSM State Transition Diagram:\n\n\n\nFSM State Transition Diagram\n\n\nHere is a state transition table for switching states:\n\n\n\n\n\n\n\n\nCurrent State\nCondition\nNext State\n\n\n\n\nS0\nbuttonPressed && oneButtonPressed\nS4\n\n\nS0\n!(buttonPressed && oneButtonPressed)\nS1\n\n\nS1\nbuttonPressed && oneButtonPressed\nS6\n\n\nS1\n!(buttonPressed && oneButtonPressed)\nS2\n\n\nS2\nbuttonPressed && oneButtonPressed\nS8\n\n\nS2\n!(buttonPressed && oneButtonPressed)\nS3\n\n\nS3\nbuttonPressed && oneButtonPressed\nS10\n\n\nS3\n!(buttonPressed && oneButtonPressed)\nS0\n\n\nS4\n!buttonPressed || !oneButtonPressed\nS1\n\n\nS4\ncounter &gt;= 50\nS5\n\n\nS4\nbuttonPressed && oneButtonPressed && counter &lt; 50\nS4\n\n\nS5\n!originalStillPressed\nS1\n\n\nS5\noriginalStillPressed\nS5\n\n\nS6\n!buttonPressed || !oneButtonPressed\nS2\n\n\nS6\ncounter &gt;= 50\nS7\n\n\nS6\nbuttonPressed && oneButtonPressed && counter &lt; 50\nS6\n\n\nS7\n!originalStillPressed\nS2\n\n\nS7\noriginalStillPressed\nS7\n\n\nS8\n!buttonPressed || !oneButtonPressed\nS3\n\n\nS8\ncounter &gt;= 50\nS9\n\n\nS8\nbuttonPressed && oneButtonPressed && counter &lt; 50\nS8\n\n\nS9\n!originalStillPressed\nS3\n\n\nS9\noriginalStillPressed\nS9\n\n\nS10\n!buttonPressed || !oneButtonPressed\nS0\n\n\nS10\ncounter &gt;= 50\nS11\n\n\nS10\nbuttonPressed && oneButtonPressed && counter &lt; 50\nS10\n\n\nS11\n!originalStillPressed\nS0\n\n\nS11\noriginalStillPressed\nS11\n\n\n\nHere is a state transition table for my outputs:\n\n\n\nState Group\nrow Output\nen Signal\nrc Output\n\n\n\n\nS0, S4, S5\n4’b0001\n1 when S4→S5\n{rowPressed, col}\n\n\nS1, S6, S7\n4’b0010\n1 when S6→S7\n{rowPressed, col}\n\n\nS2, S8, S9\n4’b0100\n1 when S8→S9\n{rowPressed, col}\n\n\nS3, S10, S11\n4’b1000\n1 when S10→S11\n{rowPressed, col}\n\n\n\nHere is the code for this submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/15/25\n\n// This module implements a finite state machine (FSM) to scan a 4x4 keypad.\n// It drives the rows and reads the columns to detect key presses, with\n// debouncing and single key press detection. The FSM operates at 1kHz,\n// with a debounce period of 50ms. The design ensures that only one key\n// press is registered at a time, and it waits for the key to be released\n// before allowing another key press to be detected.\n\nmodule keypadFSM (\n    input  logic clk,\n    input  logic reset,\n    input  logic [3:0] col,\n    output logic [3:0] row,\n    output logic [7:0] rc,\n    output logic en);\n\n    typedef enum logic [3:0] {\n        S0,       // Row0 scan\n        S1,       // Row1 scan\n        S2,       // Row2 scan\n        S3,       // Row3 scan\n        S4,       // Row0 debounce\n        S5,       // Row0 hold\n        S6,       // Row1 debounce\n        S7,       // Row1 hold\n        S8,       // Row2 debounce\n        S9,       // Row2 hold\n        S10,      // Row3 debounce\n        S11       // Row3 hold\n    } state_t;\n\n    state_t state, nextState;\n    logic [3:0] activeCol;\n    logic buttonPressed, oneButtonPressed;\n    logic [3:0] rowPressed;\n    logic [3:0] originalButton; \n    logic originalStillPressed; \n    logic [7:0] counter;\n    logic [18:0] fsm_counter;\n    logic fsm_tick;\n\n    parameter FSM_TICK_COUNT = 19'd48_000;    \n    parameter DEBOUNCE_COUNT = 8'd50;        \n\n    // 1kHz tick generator for FSM state transitions\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            fsm_counter &lt;= 0;\n            fsm_tick &lt;= 0;\n        end else begin\n            if (fsm_counter &gt;= FSM_TICK_COUNT - 1) begin\n                fsm_counter &lt;= 0;\n                fsm_tick &lt;= 1;\n            end else begin\n                fsm_counter &lt;= fsm_counter + 1;\n                fsm_tick &lt;= 0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            state &lt;= S0;\n            counter &lt;= 0;\n            originalButton &lt;= 4'b0000;\n        end else if (fsm_tick) begin\n            state &lt;= nextState;\n            \n            // Store original button when entering debounce states\n            if ((state inside {S0,S1,S2,S3}) && (nextState inside {S4,S6,S8,S10}) && oneButtonPressed) begin\n                originalButton &lt;= activeCol;\n            end\n            \n            // Clear original button when returning to scanning\n            if (nextState inside {S0,S1,S2,S3}) begin\n                originalButton &lt;= 4'b0000;\n            end\n            \n            // Debounce counter (only in debounce states)\n            if (state inside {S4,S6,S8,S10}) begin\n                if (buttonPressed && counter &lt; DEBOUNCE_COUNT)\n                    counter &lt;= counter + 1;\n                else if (!buttonPressed)\n                    counter &lt;= 0;\n            end else begin\n                counter &lt;= 0;\n            end\n        end\n    end\n\n    always_comb begin\n        case (state)\n            S0, S4, S5:     row = 4'b0001; // Row0 active\n            S1, S6, S7:     row = 4'b0010; // Row1 active\n            S2, S8, S9:     row = 4'b0100; // Row2 active\n            S3, S10, S11:   row = 4'b1000; // Row3 active\n            default:        row = 4'b0001; // Default to Row0\n        endcase\n    end\n\n    assign activeCol = col & {4{row[0] | row[1] | row[2] | row[3]}};\n\n    assign buttonPressed    = |activeCol;\n    assign oneButtonPressed = (activeCol != 0) &&\n                              ((activeCol & (activeCol - 1)) == 0);\n    \n    // Check if the original button is still pressed\n    assign originalStillPressed = (originalButton != 4'b0000) && \n                                  ((activeCol & originalButton) == originalButton);\n\n    assign rowPressed[0] = (state inside {S0, S4, S5});\n    assign rowPressed[1] = (state inside {S1, S6, S7});\n    assign rowPressed[2] = (state inside {S2, S8, S9});\n    assign rowPressed[3] = (state inside {S3, S10, S11});\n\n    assign en = fsm_tick && (\n                (nextState == S5 && state == S4) ||\n                (nextState == S7 && state == S6) ||\n                (nextState == S9 && state == S8) ||\n                (nextState == S11 && state == S10)\n              );\n\n    always_comb begin\n        case (state)\n            S0:  nextState = buttonPressed && oneButtonPressed ? S4 : S1;\n            S1:  nextState = buttonPressed && oneButtonPressed ? S6 : S2;\n            S2:  nextState = buttonPressed && oneButtonPressed ? S8 : S3;\n            S3:  nextState = buttonPressed && oneButtonPressed ? S10 : S0;\n\n            S4:  nextState = (!buttonPressed || !oneButtonPressed) ? S1 :\n                            (counter &gt;= DEBOUNCE_COUNT ? S5 : S4);\n            S5:  nextState = !originalStillPressed ? S1 : S5; \n\n            S6:  nextState = (!buttonPressed || !oneButtonPressed) ? S2 :\n                            (counter &gt;= DEBOUNCE_COUNT ? S7 : S6);\n            S7:  nextState = !originalStillPressed ? S2 : S7; \n\n            S8:  nextState = (!buttonPressed || !oneButtonPressed) ? S3 :\n                            (counter &gt;= DEBOUNCE_COUNT ? S9 : S8);\n            S9:  nextState = !originalStillPressed ? S3 : S9; \n\n            S10: nextState = (!buttonPressed || !oneButtonPressed) ? S0 :\n                            (counter &gt;= DEBOUNCE_COUNT ? S11 : S10);\n            S11: nextState = !originalStillPressed ? S0 : S11;\n\n            default: nextState = S0;\n        endcase\n    end\n\n    assign rc = {rowPressed, col};\nendmodule\n\n\nKeypad Design\nThis submodule decodes a row and column input into a 4 bit number for all our hexadecimal digits. This was designed for an active high inputs from our keypad.\nBelow is the code block that was used for this submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/13/25\n\n// This module takes in a combination of row and column inputs from the keypad,\n// and outputs a 4-bit binary representation of the key pressed. If no key is pressed,\n// the output is 4'b1111.\n\nmodule keypad (\n    input  logic [3:0] row,\n    input  logic [3:0] col,\n    output logic [3:0] key\n);\n\n    always_comb begin\n        case ({row, col})\n            8'b0001_0010: key = 4'b0000; // 0\n            8'b1000_0001: key = 4'b0001; // 1\n            8'b1000_0010: key = 4'b0010; // 2\n            8'b1000_0100: key = 4'b0011; // 3\n            8'b0100_0001: key = 4'b0100; // 4\n            8'b0100_0010: key = 4'b0101; // 5\n            8'b0100_0100: key = 4'b0110; // 6\n            8'b0010_0001: key = 4'b0111; // 7\n            8'b0010_0010: key = 4'b1000; // 8\n            8'b0010_0100: key = 4'b1001; // 9\n            8'b0001_0001: key = 4'b1010; // A\n            8'b0001_0100: key = 4'b1011; // B\n            8'b1000_1000: key = 4'b1100; // C\n            8'b0100_1000: key = 4'b1101; // D\n            8'b0010_1000: key = 4'b1110; // E\n            8'b0001_1000: key = 4'b1111; // F\n            default:      key = 4'b1111; // No key pressed\n        endcase\n    end\nendmodule\n\n\nSeven Segment Digits Design\nThis submodule stores the digits displayed on our dual 7-segment display and will add new numbers on the right and shift the old values to the left when instructed by the keypad FSM.\nBelow is the code block that was used for this submodule:\n// Christian Wu\n// chrwu@g.hmc.edu \n// 09/13/25\n\n// This module stores the last two hexadecimal digits pressed on the keypad, and outputs them to be displayed\n// on a dual seven segment display. When a new key is pressed, the previous key is shifted to the left digit,\n// and the new key is displayed on the right digit.\n\nmodule sevenSegDigits (\n    input  logic clk,\n    input  logic reset,\n    input  logic en,\n    input  logic [3:0] key,\n    output logic [3:0] s1,\n    output logic [3:0] s2);\n\n    logic en_prev;\n    logic en_edge;\n    \n    // Detect rising edge of enable signal\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            en_prev &lt;= 1'b0;\n        end else begin\n            en_prev &lt;= en;\n        end\n    end\n    \n    assign en_edge = en & ~en_prev;\n    \n    // Update digits on enable edge\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            s1 &lt;= 4'b0000; // Reset left digit to 0\n            s2 &lt;= 4'b0000; // Reset right digit to 0\n        end else if (en_edge) begin\n            // When a new key is detected, shift digits\n            s1 &lt;= s2;   // Shift the previous right digit to the left\n            s2 &lt;= key;  // Update the right digit with the new key\n        end\n    end\n\nendmodule\n\n\nTime Multiplexer Design\nThis submodule is taken from Lab 2. The main purpose of the timeMultiplexer submodule is to switch between each common anode on our dual 7-segment display, so that we only need one sevenSegmentDisplay submodule to control both digits. Thus, we are turning on one side of the dual 7-segment display on at a time, but if we do it fast enough, the human eye cannot notice each digit turning on and off. To switch between the two common anodes fast enough, I chose to switch between each display at 500 Hz. This is done by using the FPGA’s onboard 48 MHz clock, and using a counter. 500 Hz is equivalent to 0.002 seconds per cycle, and assuming a 50% duty cycle, we must switch from one common anode to the other every 0.001 seconds. For a 48 MHz clock, this would equate to 48000 ticks. Thus, we can use a counter to turn each side of the dual 7-segment display on or off, every 48000 ticks. At the same time, we can also output, signal, to tell the sevenSegMux submodule, which input to display on the corresponding side of the dual 7-segment display\nBelow is the code for the timeMultiplexer submodule:\n//  timeMultiplexer.sv\n//  Christian Wu\n//  chrwu@g.hmc.edu\n//  09/06/25\n\n// This module takes in two four bit inputs, s1 and s2, and switches between them to drive a dual seven\n// segment display, to utilize only one sevenSegmentDisplay module. The switching is done at a rate fast enough\n// such that the human eye cannot detect the switching, and it appears that both displays are on at the same time.\n\nmodule timeMultiplexer (\n    input clk,\n    output logic an1, an2,\n    output logic signal);\n\n    logic [24:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        counter &lt;= counter + 1;\n        if (counter == 48000) begin\n            counter &lt;= 0;\n            signal &lt;= ~signal; \n            if (~signal) begin\n                an1 &lt;= 1; // turn off an1\n                an2 &lt;= 0; // turn on an2\n            end else begin\n                an1 &lt;= 0; // turn on an1\n                an2 &lt;= 1; // turn off an2\n            end\n\n    end\n    end\nendmodule\n\n\nSeven Segment Mux Design\nThe design for the sevenSegMux submodule is quite simple. This submodule depicts a simple mux with an enable on it. This submodule is used to output the correct 4 bit input into the sevenSegmentDisplay submodule. When the enable is on, we set the ouput to be s2, and when it is off, we set the output to be s1.\nBelow is the code for the sevenSegMux submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module takes in two 4-bit inputs, s1 and s2, and an enable, and outputs one \n// of the inputs to a 4-bit output based on the enable signal for the seven-segment display\n\nmodule sevenSegMux (\n    input logic [3:0] s1, s2,\n    input logic enable,\n    output logic [3:0] out);\n\n    always_comb begin\n        if (enable) begin\n            out = s2;\n        end else begin\n            out = s1;\n        end\n    end\nendmodule\n\n\nSeven Segment Display Design\nThis submodule is copied from Lab 1 and uses the exact same code. Designing the sevenSegmentDisplay submodule was fairly simple. It involved using a case statement to write out the outputs, seg[6:0] of the 7-segment display for all 16 possible inputs of s[3:0]. While writing the code, it is worth noting that turning on each segment of the 7-segment display was with a 0 output as the cathode is connected to each output pin.\nBelow is a labeled image of each segment of the 7-segment display and the code for this submodule, where s[0] is segment A and s[6] is segment G of the 7-segment display:\n\n\n\n7-segment display segment mapping\n\n\n// sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0].\nmodule lab1_sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\n\n\nTop Level Module\nGiven that this lab project was split into one top level module and seven submodules, the top level module is quite simple. It is a module that calls upon the seven submodules synchronizer, keypadFSM, keypad, sevenSegDigits, timeMultiplexer, sevenSegMux and sevenSegDisplay. It also calls upon the HSOSC module to take advantage of the onboard 48 MHz clock on the FPGA. This top level module, lab2_cw, will then be programmed onto the FPGA.\nBelow is the code for the top level module, lab3_cw:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/13/25\n\n// This is the top level module for Lab 3. This module will display the last two hexadecimal digits pressed\n// on the seven segment display. Simplified to use single clock with proper timing.\n\nmodule lab3_cw (\n    input logic resetInv, \n    input logic [3:0] col,\n    output logic [3:0] row,\n    output logic [6:0] seg,\n    output logic an1, an2);\n\n    logic clk;         \n    logic reset;\n    logic [7:0] rc;\n    logic [3:0] col_sync;\n    logic [3:0] key;\n    logic en;\n    logic [3:0] s1, s2;\n    logic signal;\n    logic [3:0] current_seg;       \n    \n    assign reset = ~resetInv;\n\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\n    synchronizer sync (.clk(clk), .reset(reset), .in(col), .out(col_sync));\n    keypadFSM fsm (.clk(clk), .reset(reset), .col(col_sync), .row(row), .rc(rc), .en(en));\n    keypad keypad_decode (.row(rc[7:4]), .col(rc[3:0]), .key(key));\n    sevenSegDigits digits (.clk(clk), .reset(reset), .en(en), .key(key), .s1(s1), .s2(s2));\n    timeMultiplexer timeMux (.clk(clk), .reset(reset), .an1(an1), .an2(an2), .signal(signal));\n    sevenSegMux segMux (.s1(s1), .s2(s2), .enable(signal), .out(current_seg));\n    sevenSegmentDisplay segDisplay (.s(current_seg), .seg(seg));\nendmodule\n\n\n\nTestbench Simulation and Testing\n\nTestbench Design and Results\nTo test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench for each of my eight modules, testing a different functionality of this lab with east testbench. For the synchronizer submodule, I tested the ability to synchronize and provide a stable output from a asynchronous input. For the keypadFSM submodule, I tested the state transitions and ensured that based on the right inputs, the right outputs would be given. For the keypad submodule, I tested the decoding from a row and column input to a 4 bit number. For the sevenSegDigits submodule, I tested the functionality of switching numbers on the display, based on the inputs given. For the timeMultiplexer submodule, I tested the sequential logic that occurs in this submodule to check that the submodule switches between turning on each common anode on the dual 7-segment display, and correctly outputs the right signal for the sevenSegMux to use. For the sevenSegMux submodule, I tested that the mux would output the right 4 bit value from the two 4 bit inputs, based on whether the enable was on or off. For the sevenSegmentDisplay submodule, I tested all 16 possible 4 bit inputs and made sure that the 7 bit output was correct. For the top level lab3_cw module, it was used to test that the HSOSC module worked, by sampling a few different test cases and making sure that the dual 7-segment display would show both of the values by switching between outputting each one.\nEach of the testbenches were done by using the stim/assert method, to ensure functionality automatically, without having to analyze the waveforms carefully to see if it worked or not.\n\nsynchronizer_testbench results:\nThis testbench tested the ability to synchronize an asynchronous input and provide a stable output. Below is the code used for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/17/25\n\n// testbench for synchronizer \n\n`timescale 1ns/1ps\n\nmodule synchronizer_testbench;\n\n    logic clk;\n    logic reset;\n    logic [3:0] in;\n    logic [3:0] out;\n\n    // DUT instantiation\n    synchronizer dut (\n        .clk   (clk),\n        .reset (reset),\n        .in    (in),\n        .out   (out)\n    );\n\n    // Clock generation\n    initial clk = 0;\n    always #5 clk = ~clk;\n\n    initial begin\n        // Initialize\n        reset = 1;\n        in = 4'b0000;\n        #12;\n        reset = 0;\n\n        // --- Step 1 ---\n        @(posedge clk); in = 4'b1010;\n        @(posedge clk);        \n        @(posedge clk); \n        @(posedge clk);  \n        assert(out === 4'b1010) else $error(\"Step 1 failed: out=%b\", out);\n\n        // --- Step 2 ---\n        @(posedge clk); in = 4'b1111;\n        @(posedge clk);\n        @(posedge clk);\n        @(posedge clk);\n        assert(out === 4'b1111) else $error(\"Step 2 failed: out=%b\", out);\n\n        // --- Step 3 ---\n        @(posedge clk); in = 4'b0101;\n        @(posedge clk);\n        @(posedge clk);\n        @(posedge clk);\n        assert(out === 4'b0101) else $error(\"Step 3 failed: out=%b\", out);\n\n        $display(\"All steps completed successfully\");\n        $finish;\n    end\n\nendmodule\nBelow are the Questa simulation results:\n\n\n\nsynchronizer Waveforms\n\n\n\n\n\nsynchronizer Transcript\n\n\n\n\nkeypadFSM_testbench results:\nThis testbench tested the enable and output logic of my FSM, making sure that state transitions worked adequately and gave the right results. Below if the code used for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/17/25\n\n// Testbench for keypadFSM module\n\n`timescale 1ns/1ps\n\nmodule keypadFSM_testbench();\n\n    // Signals\n    logic clk;\n    logic reset;\n    logic [3:0] col;\n    logic [3:0] row;\n    logic [7:0] rc;\n    logic en;\n\n    // Instantiate DUT\n    keypadFSM dut (\n        .clk(clk),\n        .reset(reset),\n        .col(col),\n        .row(row),\n        .rc(rc),\n        .en(en)\n    );\n\n    // Clock: 50 MHz\n    initial clk = 0;\n    always #10 clk = ~clk;\n\n    integer i;\n    logic en_seen;\n    logic [3:0] expected_col;\n\n    initial begin\n        reset = 1;\n        col = 4'b0000;\n        repeat (5) @(posedge clk);\n        reset = 0;\n\n        // Wait a few FSM ticks\n        for (i = 0; i &lt; 2*48_000; i = i + 1) @(posedge clk);\n\n        // --- Test Case 1: Row0, Col0 ---\n        col = 4'b0001;\n        expected_col = 4'b0001;\n        en_seen = 0;\n\n        // Hold key long enough (&gt; debounce)\n        for (i = 0; i &lt; 150*48_000; i = i + 1) begin\n            @(posedge clk);\n            if (en) begin\n                en_seen = 1;\n                // Check only column bits\n                if (rc[3:0] !== expected_col)\n                    $error(\"Error: column mismatch in Test Case 1! Expected %b, got %b\", expected_col, rc[3:0]);\n                // Check row is one-hot\n                if (^rc[7:4] !== 1'b1)\n                    $error(\"Error: row not one-hot in Test Case 1! rc[7:4]=%b\", rc[7:4]);\n            end\n        end\n        col = 4'b0000;\n        if (!en_seen) $error(\"Error: en not asserted in Test Case 1\");\n\n        // --- Test Case 2: Row1, Col2 ---\n        col = 4'b0100;\n        expected_col = 4'b0100;\n        en_seen = 0;\n\n        for (i = 0; i &lt; 150*48_000; i = i + 1) begin\n            @(posedge clk);\n            if (en) begin\n                en_seen = 1;\n                if (rc[3:0] !== expected_col)\n                    $error(\"Error: column mismatch in Test Case 2! Expected %b, got %b\", expected_col, rc[3:0]);\n                if (^rc[7:4] !== 1'b1)\n                    $error(\"Error: row not one-hot in Test Case 2! rc[7:4]=%b\", rc[7:4]);\n            end\n        end\n        col = 4'b0000;\n        if (!en_seen) $error(\"Error: en not asserted in Test Case 2\");\n\n        // --- Test Case 3: Multiple keys (ignored) ---\n        col = 4'b0011;\n        en_seen = 0;\n\n        for (i = 0; i &lt; 50*48_000; i = i + 1) begin\n            @(posedge clk);\n            if (en) en_seen = 1;\n        end\n        if (en_seen)\n            $error(\"Error: en asserted with multiple keys in Test Case 3\");\n        col = 4'b0000;\n\n        $display(\"All tests completed successfully.\");\n        $stop;\n    end\n\nendmodule\nBelow are the Questa simulation results:\n\n\n\nkeypadFSM Waveforms\n\n\n\n\n\nkeypadFSM Transcript\n\n\n\n\nkeypad_testbench results:\nThis testbench tested the decoding of a row and column on a keypad into a 4 bit number. Below if the code used for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/13/25\n\n// This module is a testbench for the keypad decoder module. It tests all possible key presses\n// and verifies that the correct key code is output. It also includes edge case tests to ensure\n// robustness of the keypad decoder.\n\n`timescale 1ns/1ps\n\nmodule keypad_testbench();\n    \n    // Testbench signals\n    logic [3:0] row;\n    logic [3:0] col;\n    logic [3:0] key;\n    \n    // Instantiate the keypad decoder\n    keypad dut (\n        .row(row),\n        .col(col),\n        .key(key)\n    );\n    \n    // Main stimulus and test sequence\n    initial begin\n        \n        // Test 1: Key '1' - Row 0 (0001), Col 0 (0001) -&gt; 0001_0001\n        row = 4'b1000; col = 4'b0001; #10;\n        assert(key == 4'b0001) else $error(\"Key '1' failed: expected 4'b0001, got %b\", key);\n        \n        // Test 2: Key '2' - Row 0 (1000), Col 1 (0010) -&gt; 1000_0010\n        row = 4'b1000; col = 4'b0010; #10;\n        assert(key == 4'b0010) else $error(\"Key '2' failed: expected 4'b0010, got %b\", key);\n        \n        // Test 3: Key '3' - Row 0 (1000), Col 2 (0100) -&gt; 1000_0100\n        row = 4'b1000; col = 4'b0100; #10;\n        assert(key == 4'b0011) else $error(\"Key '3' failed: expected 4'b0011, got %b\", key);\n        \n        // Test 4: Key 'C' - Row 0 (1000), Col 3 (1000) -&gt; 1000_1000\n        row = 4'b1000; col = 4'b1000; #10;\n        assert(key == 4'b1100) else $error(\"Key 'C' failed: expected 4'b1100, got %b\", key);\n        \n        // Test 5: Key '4' - Row 1 (0100), Col 0 (0001) -&gt; 0100_0001\n        row = 4'b0100; col = 4'b0001; #10;\n        assert(key == 4'b0100) else $error(\"Key '4' failed: expected 4'b0100, got %b\", key);\n        \n        // Test 6: Key '5' - Row 1 (0100), Col 1 (0010) -&gt; 0100_0010\n        row = 4'b0100; col = 4'b0010; #10;\n        assert(key == 4'b0101) else $error(\"Key '5' failed: expected 4'b0101, got %b\", key);\n        \n        // Test 7: Key '6' - Row 1 (0100), Col 2 (0100) -&gt; 0100_0100\n        row = 4'b0100; col = 4'b0100; #10;\n        assert(key == 4'b0110) else $error(\"Key '6' failed: expected 4'b0110, got %b\", key);\n        \n        // Test 8: Key 'D' - Row 1 (0100), Col 3 (1000) -&gt; 0100_1000\n        row = 4'b0100; col = 4'b1000; #10;\n        assert(key == 4'b1101) else $error(\"Key 'D' failed: expected 4'b1101, got %b\", key);\n        \n        // Test 9: Key '7' - Row 2 (0010), Col 0 (0001) -&gt; 0010_0001\n        row = 4'b0010; col = 4'b0001; #10;\n        assert(key == 4'b0111) else $error(\"Key '7' failed: expected 4'b0111, got %b\", key);\n        \n        // Test 10: Key '8' - Row 2 (0010), Col 1 (0010) -&gt; 0010_0010\n        row = 4'b0010; col = 4'b0010; #10;\n        assert(key == 4'b1000) else $error(\"Key '8' failed: expected 4'b1000, got %b\", key);\n        \n        // Test 11: Key '9' - Row 2 (0010), Col 2 (0100) -&gt; 0010_0100\n        row = 4'b0010; col = 4'b0100; #10;\n        assert(key == 4'b1001) else $error(\"Key '9' failed: expected 4'b1001, got %b\", key);\n        \n        // Test 12: Key 'E' - Row 2 (0010), Col 3 (1000) -&gt; 0010_1000\n        row = 4'b0010; col = 4'b1000; #10;\n        assert(key == 4'b1110) else $error(\"Key 'E' failed: expected 4'b1110, got %b\", key);\n        \n        // Test 13: Key 'A' - Row 3 (0001), Col 0 (0001) -&gt; 0001_0001\n        row = 4'b0001; col = 4'b0001; #10;\n        assert(key == 4'b1010) else $error(\"Key 'A' failed: expected 4'b1010, got %b\", key);\n        \n        // Test 14: Key '0' - Row 3 (0001), Col 1 (0010) -&gt; 0001_0010\n        row = 4'b0001; col = 4'b0010; #10;\n        assert(key == 4'b0000) else $error(\"Key '0' failed: expected 4'b0000, got %b\", key);\n        \n        // Test 15: Key 'B' - Row 3 (0001), Col 2 (0100) -&gt; 0001_0100\n        row = 4'b0001; col = 4'b0100; #10;\n        assert(key == 4'b1011) else $error(\"Key 'B' failed: expected 4'b1011, got %b\", key);\n        \n        // Test 16: Key 'F' - Row 3 (0001), Col 3 (1000) -&gt; 0001_1000\n        row = 4'b0001; col = 4'b1000; #10;\n        assert(key == 4'b1111) else $error(\"Key 'F' failed: expected 4'b1111, got %b\", key);\n        \n        // Edge Case Tests\n        // Test 17: No key pressed\n        row = 4'b0000; col = 4'b0000; #10;\n        assert(key == 4'b1111) else $error(\"No key pressed failed: expected 4'b1111, got %b\", key);\n        \n        // Test 18: Multiple rows active (invalid)\n        row = 4'b0011; col = 4'b0001; #10;\n        assert(key == 4'b1111) else $error(\"Multiple rows test failed: expected 4'b1111, got %b\", key);\n        \n        // Test 19: Multiple columns active (invalid)\n        row = 4'b0001; col = 4'b0011; #10;\n        assert(key == 4'b1111) else $error(\"Multiple columns test failed: expected 4'b1111, got %b\", key);\n        \n        // Test 20: Both multiple rows and columns (invalid)\n        row = 4'b0011; col = 4'b0011; #10;\n        assert(key == 4'b1111) else $error(\"Multiple rows and columns failed: expected 4'b1111, got %b\", key);\n        \n        // Test 21: All ones (invalid)\n        row = 4'b1111; col = 4'b1111; #10;\n        assert(key == 4'b1111) else $error(\"All ones test failed: expected 4'b1111, got %b\", key);\n\n        // Test 22: Only one row high, no column high\n        row = 4'b0001; col = 4'b0000; #10;\n        assert(key == 4'b1111) else $error(\"Row high only failed: expected 4'b1111, got %b\", key);\n        \n        // Test 23: Only one column high, no row high  \n        row = 4'b0000; col = 4'b0001; #10;\n        assert(key == 4'b1111) else $error(\"Column high only failed: expected 4'b1111, got %b\", key);\n        \n        $display(\"\\nAll tests successfully completed.\");\n        $stop;\n    end\nendmodule\nBelow are the Questa simulation results:\n\n\n\nkeypad Waveforms\n\n\n\n\n\nkeypad Transcript\n\n\n\n\nsevenSegDigits_testbench results:\nThis testbench tested the proper display of numbers on the dual 7-segment display, ensuring the correct shifting of numbers. Below if the code used for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/15/25\n\n// This module is a testbench for the sevenSegDigits module. It tests the digit storage\n// and shifting functionality with proper timing for synchronous reset and enable signals.\n\n`timescale 1ns / 1ps\n\nmodule sevenSegDigits_testbench();\n    \n    logic clk;\n    logic reset;\n    logic en;\n    logic [3:0] key;\n    logic [3:0] s1, s2;\n    \n    int test_count = 0;\n    logic [3:0] s1_before, s2_before; // keep these at module scope\n    \n    initial clk = 0;\n    always #10 clk = ~clk;\n    \n    sevenSegDigits dut (\n        .clk(clk),\n        .reset(reset),\n        .en(en),\n        .key(key),\n        .s1(s1),\n        .s2(s2)\n    );\n    \n    initial begin\n        \n        reset = 1;\n        en = 0;\n        key = 4'h0;\n        \n        @(posedge clk);\n        @(posedge clk); \n        \n        // Test 1: Reset behavior\n        test_count++;\n        assert (s1 == 4'h0 && s2 == 4'h0) else\n            $error(\"Test %0d FAILED: Reset should set both digits to 0. Got s1=%h, s2=%h\", test_count, s1, s2);\n        \n        // Release reset and wait a posedge for stable operation\n        reset = 0;\n        @(posedge clk);\n        \n        // Test 2: First key press\n        test_count++;\n        key = 4'h5; en = 1;\n        @(posedge clk); en = 0;      \n        @(posedge clk);             \n        assert (s1 == 4'h0 && s2 == 4'h5) else\n            $error(\"Test %0d FAILED: First key should be s1=0, s2=5. Got s1=%h, s2=%h\", test_count, s1, s2);\n        \n        // Test 3: Second key press\n        test_count++;\n        key = 4'hA; en = 1;\n        @(posedge clk); en = 0;\n        @(posedge clk);\n        assert (s1 == 4'h5 && s2 == 4'hA) else\n            $error(\"Test %0d FAILED: Second key should be s1=5, s2=A. Got s1=%h, s2=%h\", test_count, s1, s2);\n        \n        // Test 4: Third key press\n        test_count++;\n        key = 4'hF; en = 1;\n        @(posedge clk); en = 0;\n        @(posedge clk);\n        assert (s1 == 4'hA && s2 == 4'hF) else\n            $error(\"Test %0d FAILED: Third key should be s1=A, s2=F. Got s1=%h, s2=%h\", test_count, s1, s2);\n        \n        // Test 5: Enable held high (keep key stable while en is high)\n        test_count++;\n        key = 4'h7;\n        en = 1;\n        @(posedge clk);\n        @(posedge clk); \n        @(posedge clk); \n        en = 0;\n        @(posedge clk);\n        assert (s1 == 4'hF && s2 == 4'h7) else\n            $error(\"Test %0d FAILED: Enable high should only update once. Got s1=%h, s2=%h\", test_count, s1, s2);\n        \n        // Test 6: No enable (change key while en==0)\n        test_count++;\n        s1_before = s1;\n        s2_before = s2;\n        key = 4'h9;   \n        @(posedge clk);    \n        @(posedge clk);\n        assert (s1 == s1_before && s2 == s2_before) else\n            $error(\"Test %0d FAILED: No enable should not update. Got s1=%h, s2=%h, expected s1=%h, s2=%h\", \n                   test_count, s1, s2, s1_before, s2_before);\n        \n        // Test 7: All hex digits\n        test_count++;\n        for (int i = 0; i &lt; 16; i++) begin\n            key = i[3:0]; en = 1;\n            @(posedge clk); en = 0; @(posedge clk); \n            assert (s2 == i[3:0]) else\n                $error(\"Hex test FAILED: Key %h not stored correctly. Got s2=%h\", i[3:0], s2);\n        end\n        \n        $display(\"All %0d tests completed successfully\", test_count);\n        $stop;\n    end\n    \n    // Continuous assertions - only check when not in reset and outputs are not X\n    always @(posedge clk) begin\n        if (!reset && s1 !== 4'bxxxx && s2 !== 4'bxxxx) begin\n            assert (s1 &lt;= 4'hF && s2 &lt;= 4'hF) else\n                $error(\"ASSERTION: Outputs should be valid hex (0-F). Got s1=%h, s2=%h\", s1, s2);\n        end\n    end\n    \n    // Safety timeout\n    initial begin\n        #50000; // 50us timeout\n        $display(\"Testbench timeout\");\n        $finish;\n    end\n    \nendmodule\nBelow are the Questa simulation results:\n\n\n\nsevenSegDigits Waveforms\n\n\n\n\n\nsevenSegDigits Transcript\n\n\n\n\ntimeMultiplexer_testbench results:\nThis testbench tested the sequential logic of switching between turning on each common anode, and outputting the right signal for the sevenSegmentMux submodule. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the timeMultiplexer module by simulating clock cycles and checking if the an1, an2, and signal outputs\n// toggle correctly based on the internal counter.\n\n// timeMultiplexer_simple_tb.sv\n// Simple testbench focusing only on an1 and an2 switching behavior\n\n`timescale 1ns / 1ps\n\nmodule timeMultiplexer_testbench();\n    logic clk;\n    logic an1, an2;\n    logic signal;\n    \n    timeMultiplexer dut (.clk(clk), .an1(an1), .an2(an2), .signal(signal));\n    \n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; \n    end\n    \n    // Test sequence\n    initial begin\n        repeat(10) begin\n            @(posedge signal or negedge signal);\n            #1;\n        end\n        \n        $display(\"Test completed successfully.\");\n        $stop;\n    end\n    \n    // Assert statements for anode behavior\n    always @(*) begin\n        // Assert anodes are always opposite (mutually exclusive)\n        assert (an1 !== an2)\n        else $error(\"Anodes not mutually exclusive: an1=%b, an2=%b\", an1, an2);\n        \n        // Assert correct anode control based on signal\n        assert (signal ? (an1 == 1 && an2 == 0) : (an1 == 0 && an2 == 1))\n        else $error(\"Incorrect anode control: signal=%b, an1=%b, an2=%b\", signal, an1, an2);\n        \n        // Assert only one display is active at a time (one anode is 0)\n        assert ((an1 == 0) ^ (an2 == 0))\n        else $error(\"Neither or both displays active: an1=%b, an2=%b\", an1, an2);\n    end\n    \nendmodule\nI also used an oscilloscope to confirm that the switching between the two sides of the dual 7-segment display is at 500 Hz:\n\n\n\nOscilloscope trace switching displays at 500 Hz\n\n\nBelow are the Questa simulation results:\n\n\n\ntimeMultiplexer Waveforms\n\n\n\n\n\ntimeMultiplexer Transcript\n\n\n\n\nsevenSegMux_testbench results:\nThis testbench tested that the mux worked as expected, testing all 512 cases. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the sevenSegMux module by inputing all combinations of s1, s2, and enable signals\n// and checking if the output is as expected.\n\n`timescale 1ns/1ps\n\nmodule sevenSegMux_testbench();\n    logic [3:0] s1, s2;\n    logic enable;\n    logic [3:0] out;\n    sevenSegMux dut (.s1(s1), .s2(s2), .enable(enable), .out(out));\n\n    integer i, j;\n    integer errors = 0;\n    integer test_cases = 0;\n    logic [3:0] expected_out;\n\n    initial begin\n        // Test all combinations of 4-bit inputs and enable signal\n        for (i = 0; i &lt; 16; i++) begin\n            for (j = 0; j &lt; 16; j++) begin\n                s1 = i[3:0];\n                s2 = j[3:0];\n\n                // Test with enable = 0\n                enable = 0;\n                #10; \n                test_cases++;\n                expected_out = s1;\n                assert (out === expected_out)\n                    else $error(\"ASSERTION FAILED: s1=%0d, s2=%0d, enable=0, expected out=%0d, got out=%0d\", s1, s2, expected_out, out);\n\n                // Test with enable = 1\n                enable = 1;\n                #10; \n                test_cases++;\n                expected_out = s2;\n                assert (out === expected_out)\n                    else $error(\"ASSERTION FAILED: s1=%0d, s2=%0d, enable=1, expected out=%0d, got out=%0d\", s1, s2, expected_out, out);\n            end\n        end\n\n        $display(\"All %0d test cases successfully completed.\", test_cases);\n        $stop;\n    end\n    endmodule\nBelow are the Questa simulation results:\n\n\n\nsevenSegMux Waveforms\n\n\n\n\n\nsevenSegMux Transcript\n\n\n\n\nsevenSegmentDisplay_testbench results:\nThis testbench tested the combinational logic of the sevenSegmentDisplay submodule, testing all 16 cases. Below is the code used for my testbench:\n// sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0]. This module is copy and pasted from lab 1\nmodule sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\nBelow are the results of the Questa simulation of this testbench:\n\n\n\nsevenSegmentDisplay Waveforms\n\n\n\n\n\nsevenSegmentDisplay Transcript\n\n\n\n\nlab3_cw_testbench results:\nThis testbench tested the HSOSC module and the overall functionality of this lab by using a few sample test cases. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/17/25\n\n// Testbench for lab3_cw\n\n`timescale 1ns/1ps\n\nmodule lab3_cw_testbench(); \n    logic clk;\n    logic resetInv;  \n    logic [3:0] col;\n    logic [3:0] row;\n    logic an1, an2;\n    logic [6:0] seg;\n\n    lab3_cw dut(.resetInv(resetInv), .col(col), .row(row), .seg(seg), .an1(an1), .an2(an2));\n\n    always begin\n        clk = 0; #10.42;  // ~48MHz clock period\n        clk = 1; #10.42;\n    end\n\n    initial begin\n        resetInv = 0; #100;  \n        resetInv = 1;    \n    end\n    \n    initial begin\n        col = 4'b0000;\n        \n        wait(resetInv == 1);\n        #1_000_000;  // 1ms delay\n        \n        $display(\"Starting keypad test sequence...\");\n        \n        // Test Key 1: Row 0 (4'b0001), Col 0 (4'b0001)\n        wait(row == 4'b0001);  \n        #1000;\n        col = 4'b0001;\n        $display(\"Time %0t: Pressing key 1 - Row: %b, Col: %b\", $time, row, col);\n        #60_000_000;  \n        col = 4'b0000;\n        $display(\"Time %0t: Released key 1\", $time);\n        #10_000_000;\n        \n        // Test Key 2: Row 0 (4'b0001), Col 1 (4'b0010)\n        wait(row == 4'b0001);  \n        #1000;\n        col = 4'b0010;\n        $display(\"Time %0t: Pressing key 2 - Row: %b, Col: %b\", $time, row, col);\n        #60_000_000; \n        col = 4'b0000;\n        $display(\"Time %0t: Released key 2\", $time);\n        #10_000_000;\n        \n        // Test Key 3: Row 0 (4'b0001), Col 2 (4'b0100)\n        wait(row == 4'b0001);  \n        #1000;\n        col = 4'b0100;\n        $display(\"Time %0t: Pressing key 3 - Row: %b, Col: %b\", $time, row, col);\n        #60_000_000;\n        col = 4'b0000;\n        $display(\"Time %0t: Released key 3\", $time);\n        #10_000_000;\n        \n        // Test Key A: Row 3 (4'b1000), Col 0 (4'b0001)\n        wait(row == 4'b1000);  \n        #1000;\n        col = 4'b0001;\n        $display(\"Time %0t: Pressing key A - Row: %b, Col: %b\", $time, row, col);\n        #60_000_000;  \n        col = 4'b0000;\n        $display(\"Time %0t: Released key A\", $time);\n        #10_000_000;\n        \n        #100_000_000;\n        \n        $display(\"Tests completed\");\n        $finish;\n    end\n\nendmodule\nBelow are my Questa simulation results:\n\n\n\nlab3_cw Waveforms\n\n\nThus, all testbenches and testing for this lab was successful!\n\n\n\n\nHardware\n\nDesign and Schematic\nAfter finishing with testing, I can now build my hardware and program my FPGA. Below, is a table of all of my pin assignments, as well as my schematic:\n\nPin assignments for Lab 3 inputs and outputs\n\n\nName\nPin\n\n\n\n\nreset\n43\n\n\nrow[0]\n37\n\n\nrow[1]\n31\n\n\nrow[2]\n35\n\n\nrow[3]\n32\n\n\ncol[0]\n44\n\n\ncol[1]\n3\n\n\ncol[2]\n45\n\n\ncol[3]\n46\n\n\nan1\n10\n\n\nan2\n2\n\n\nseg[0]\n21\n\n\nseg[1]\n19\n\n\nseg[2]\n11\n\n\nseg[3]\n6\n\n\nseg[4]\n4\n\n\nseg[5]\n48\n\n\nseg[6]\n47\n\n\n\n\n\n\nLab 3 Schematic\n\n\nDual 7-segment Display Resistor Values\nFor the 7-segment display, resistors were added at each of the seven segment pins to prevent the display from drawing too much current. After referencing the HDSP-521A Seven Segment Display Datasheet, I found that the forward voltage for the display is 1.7 V. Given that we are using a 3.3 V source voltage from the FPGA, the voltage across the resistor is 1.6 V. We need to keep the current under 8 mA, which is the maximum for our ice40, so to keep it clean, I used 220 Ohm Resistors, giving a current of 7.3 mA.\n2N3906 Transistor Base Resistor Value\nWe are supplying 3.3 V to our 2N3906 PNP Transistor. We know from the data sheetthat the Base Emitter Voltage is around 0.7, so we have 2.6 V that will be dropped through the resistor that connects the base to the GPIO Pin. From the iice40 Datasheet, we know from Table 4.17 that I_OL = 8 mA. Thus, we know that we want the current to be between 1 and 8 mA. I chose to use a 1 k Ohm resistor, which gives a current of 2.6 mA, giving ample wiggle room on both ends. Below is a picture that models this math:\n\n\n\nTransistor Resistor Value Math\n\n\n\n\nResults\nAfter finishing with the design, I was able to wire my board according to the schematic and programming my top level module, lab3_cw, onto my board. I was able to physically verify that everything worked as expected.\nBelow is a video demonstrating this lab working successfully:\n\n\nVideo\nSuccessful Keypad Decoder\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype",
    "href": "labs/lab3/lab3.html#ai-prototype",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt 1\nTo test how AI would do for this lab, I entered the following prompt to Claude AI:\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\n* A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator.\n* A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release.\n* A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness.\nUse idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\nAI Code\nAs a result, it returned the following code:\n// Top-level module for 4x4 keypad scanner with dual 7-segment display\n// Targets Lattice iCE40 UP5K FPGA with ~20 MHz internal oscillator\nmodule keypad_display_top (\n    input  logic       clk,           // ~20 MHz internal oscillator\n    input  logic       rst_n,         // Active-low reset\n    \n    // Keypad interface (active-low)\n    output logic [3:0] col_n,         // Column outputs (active-low)\n    input  logic [3:0] row_n,         // Row inputs (active-low, pulled up)\n    \n    // 7-segment display interface\n    output logic [6:0] seg_n,         // 7-segment outputs (active-low)\n    output logic [1:0] dig_sel_n      // Digit select (active-low)\n);\n\n    // Internal signals\n    logic scan_clk;                   // ~150 Hz scan clock\n    logic display_clk;                // ~1 kHz display multiplex clock\n    logic [3:0] key_pressed;          // Current key value (0-F)\n    logic key_valid;                  // Key press event pulse\n    \n    // Instantiate clock divider\n    clock_divider clk_div (\n        .clk(clk),\n        .rst_n(rst_n),\n        .scan_clk(scan_clk),\n        .display_clk(display_clk)\n    );\n    \n    // Instantiate keypad scanner\n    keypad_scanner scanner (\n        .clk(clk),\n        .rst_n(rst_n),\n        .scan_clk(scan_clk),\n        .col_n(col_n),\n        .row_n(row_n),\n        .key_pressed(key_pressed),\n        .key_valid(key_valid)\n    );\n    \n    // Instantiate display controller\n    display_controller display (\n        .clk(clk),\n        .rst_n(rst_n),\n        .display_clk(display_clk),\n        .key_pressed(key_pressed),\n        .key_valid(key_valid),\n        .seg_n(seg_n),\n        .dig_sel_n(dig_sel_n)\n    );\n\nendmodule\n\n// Clock divider module\n// Generates scan clock (~150 Hz) and display multiplex clock (~1 kHz)\nmodule clock_divider (\n    input  logic clk,           // ~20 MHz input clock\n    input  logic rst_n,\n    output logic scan_clk,      // ~150 Hz for keypad scanning\n    output logic display_clk    // ~1 kHz for display multiplexing\n);\n\n    // Clock divider counters\n    // For 20 MHz input: scan_clk = 20M / (2^17) ≈ 153 Hz\n    logic [16:0] scan_counter;\n    // For display_clk = 20M / (2^14) ≈ 1.2 kHz\n    logic [13:0] display_counter;\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            scan_counter &lt;= '0;\n            display_counter &lt;= '0;\n        end else begin\n            scan_counter &lt;= scan_counter + 1;\n            display_counter &lt;= display_counter + 1;\n        end\n    end\n    \n    assign scan_clk = scan_counter[16];\n    assign display_clk = display_counter[13];\n\nendmodule\n\n// Keypad scanner with debouncing\n// Scans 4x4 matrix keypad, registers one key per press with debounce-by-design\nmodule keypad_scanner (\n    input  logic       clk,\n    input  logic       rst_n,\n    input  logic       scan_clk,\n    output logic [3:0] col_n,         // Active-low column outputs\n    input  logic [3:0] row_n,         // Active-low row inputs\n    output logic [3:0] key_pressed,   // Registered key value\n    output logic       key_valid      // Key press event (single cycle pulse)\n);\n\n    // FSM states\n    typedef enum logic [1:0] {\n        IDLE,           // No key pressed, ready to scan\n        KEY_DETECTED,   // Key detected, wait for stable reading\n        KEY_HELD        // Key registered, wait for release\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // Scan control\n    logic [1:0] col_select;           // Current column being scanned (0-3)\n    logic [3:0] col_decoded;          // One-hot column select\n    logic [3:0] row_sync;             // Synchronized row inputs\n    \n    // Key detection\n    logic key_detected;\n    logic [3:0] detected_key;\n    \n    // Column decoder: converts 2-bit select to one-hot (active-low)\n    always_comb begin\n        col_decoded = 4'b1111;  // Default all inactive\n        col_decoded[col_select] = 1'b0;  // Activate selected column\n    end\n    \n    assign col_n = col_decoded;\n    \n    // Synchronize row inputs (2 FF synchronizer)\n    logic [3:0] row_sync1;\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            row_sync1 &lt;= 4'b1111;\n            row_sync &lt;= 4'b1111;\n        end else begin\n            row_sync1 &lt;= row_n;\n            row_sync &lt;= row_sync1;\n        end\n    end\n    \n    // Key detection logic\n    always_comb begin\n        key_detected = 1'b0;\n        detected_key = 4'h0;\n        \n        // Check for active row in current column\n        for (int i = 0; i &lt; 4; i++) begin\n            if (!row_sync[i]) begin  // Active-low row detected\n                key_detected = 1'b1;\n                // Calculate key value: row * 4 + col\n                detected_key = {i[1:0], col_select};\n                break;  // Only register first detected key\n            end\n        end\n    end\n    \n    // Column scanning counter (advances on scan_clk)\n    logic scan_clk_prev;\n    logic scan_edge;\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            scan_clk_prev &lt;= 1'b0;\n        end else begin\n            scan_clk_prev &lt;= scan_clk;\n        end\n    end\n    \n    assign scan_edge = scan_clk && !scan_clk_prev;\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            col_select &lt;= 2'b00;\n        end else if (scan_edge) begin\n            col_select &lt;= col_select + 1;  // Cycles through 0-3\n        end\n    end\n    \n    // Main FSM\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state &lt;= IDLE;\n        end else begin\n            state &lt;= next_state;\n        end\n    end\n    \n    always_comb begin\n        next_state = state;\n        \n        case (state)\n            IDLE: begin\n                if (key_detected) begin\n                    next_state = KEY_DETECTED;\n                end\n            end\n            \n            KEY_DETECTED: begin\n                if (!key_detected) begin\n                    next_state = IDLE;  // False detection, go back\n                end else if (scan_edge) begin\n                    next_state = KEY_HELD;  // Stable for full scan cycle\n                end\n            end\n            \n            KEY_HELD: begin\n                if (!key_detected) begin\n                    next_state = IDLE;  // Key released\n                end\n            end\n        endcase\n    end\n    \n    // Output registration\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            key_pressed &lt;= 4'h0;\n            key_valid &lt;= 1'b0;\n        end else begin\n            key_valid &lt;= 1'b0;  // Default to no pulse\n            \n            if (state == KEY_DETECTED && next_state == KEY_HELD) begin\n                key_pressed &lt;= detected_key;\n                key_valid &lt;= 1'b1;  // Generate single-cycle pulse\n            end\n        end\n    end\n\nendmodule\n\n// Display controller with time multiplexing\n// Maintains two hex digits and drives 7-segment display without flicker\nmodule display_controller (\n    input  logic       clk,\n    input  logic       rst_n,\n    input  logic       display_clk,\n    input  logic [3:0] key_pressed,\n    input  logic       key_valid,\n    output logic [6:0] seg_n,         // 7-segment outputs (active-low)\n    output logic [1:0] dig_sel_n      // Digit select (active-low)\n);\n\n    // Stored digits (older and newer)\n    logic [3:0] digit_old, digit_new;\n    \n    // Display multiplexing\n    logic display_select;             // 0 = digit_old, 1 = digit_new\n    logic [3:0] current_digit;\n    \n    // Update stored digits on new key press\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            digit_old &lt;= 4'h0;\n            digit_new &lt;= 4'h0;\n        end else if (key_valid) begin\n            digit_old &lt;= digit_new;     // Shift: new becomes old\n            digit_new &lt;= key_pressed;  // Store new key\n        end\n    end\n    \n    // Display multiplexer (toggles on display_clk edge)\n    logic display_clk_prev;\n    logic display_edge;\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            display_clk_prev &lt;= 1'b0;\n        end else begin\n            display_clk_prev &lt;= display_clk;\n        end\n    end\n    \n    assign display_edge = display_clk && !display_clk_prev;\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            display_select &lt;= 1'b0;\n        end else if (display_edge) begin\n            display_select &lt;= ~display_select;\n        end\n    end\n    \n    // Select current digit and digit enable\n    always_comb begin\n        if (display_select) begin\n            current_digit = digit_new;\n            dig_sel_n = 2'b01;  // Enable right digit (newer)\n        end else begin\n            current_digit = digit_old;\n            dig_sel_n = 2'b10;  // Enable left digit (older)\n        end\n    end\n    \n    // 7-segment decoder (hex to 7-segment, active-low outputs)\n    always_comb begin\n        case (current_digit)\n            4'h0: seg_n = 7'b1000000;  // 0\n            4'h1: seg_n = 7'b1111001;  // 1\n            4'h2: seg_n = 7'b0100100;  // 2\n            4'h3: seg_n = 7'b0110000;  // 3\n            4'h4: seg_n = 7'b0011001;  // 4\n            4'h5: seg_n = 7'b0010010;  // 5\n            4'h6: seg_n = 7'b0000010;  // 6\n            4'h7: seg_n = 7'b1111000;  // 7\n            4'h8: seg_n = 7'b0000000;  // 8\n            4'h9: seg_n = 7'b0010000;  // 9\n            4'hA: seg_n = 7'b0001000;  // A\n            4'hB: seg_n = 7'b0000011;  // b\n            4'hC: seg_n = 7'b1000110;  // C\n            4'hD: seg_n = 7'b0100001;  // d\n            4'hE: seg_n = 7'b0000110;  // E\n            4'hF: seg_n = 7'b0001110;  // F\n        endcase\n    end\n\nendmodule\n\n\nTest in Radiant\nI then started a new project in Radiant and attempted to synthesize the code. Claude was able to synthesize properly and it seems like it would actually work quite well, which is really impressive. I would need to add the HSOSC module to be able to utilize the FPGA’s onboard clock to run this. But overall, it worked quite well\n\n\n\nModular Prompts\nI then ran the second prompt by using modular prompts. I used the following prompts:\nTarget device: Lattice iCE40 UP5K FPGA.\n\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\n\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\n\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse.\nWhile any key remains pressed, do not accept additional keys.\nOnly after keys are released should a subsequent press be recognized.\nThis should handle debouncing of the keys.\nImplement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here\nTarget device: Lattice iCE40 UP5K FPGA.\n\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\n\nIterate columns at a suitable scan rate derived from the divided clock and sample rows.\nWhen a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed.\nProvide a boolean signal indicating whether any key is currently pressed.\nUse clean state encoding and synchronous logic; avoid combinational feedback and latches.\nTarget device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\n\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\n\nUpdate the displayed digits only when a new key is registered.\nEnsure equal apparent brightness and no visible flicker.\nKeep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs.\nProvide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\nAI Code Result\nClaude gave me the following code.\nmodule keypad_oneshot (\n    input  logic        clk,\n    input  logic        rst_n,\n    input  logic        key_valid,     // From keypad scanner - high when any key detected\n    input  logic [3:0]  key_code,      // From keypad scanner - current key code\n    \n    output logic        new_key_pulse, // Single-cycle pulse when new key registered\n    output logic [3:0]  captured_key   // Stable key code output\n);\n\n    // FSM States\n    typedef enum logic [1:0] {\n        IDLE        = 2'b00,  // No key pressed, ready for new press\n        DEBOUNCE    = 2'b01,  // Key detected, debouncing\n        KEY_HELD    = 2'b10,  // Key validated and held, waiting for release\n        RELEASE_DEB = 2'b11   // Key released, debouncing release\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // Debounce counter - adjust DEBOUNCE_COUNT based on your clock frequency\n    // For 12MHz clock, 240 cycles = ~20us debounce time\n    localparam int DEBOUNCE_COUNT = 240;\n    localparam int COUNTER_WIDTH = $clog2(DEBOUNCE_COUNT + 1);\n    \n    logic [COUNTER_WIDTH-1:0] debounce_counter;\n    logic debounce_done;\n    logic [3:0] key_code_reg;\n    \n    // Debounce counter logic\n    assign debounce_done = (debounce_counter == DEBOUNCE_COUNT);\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            debounce_counter &lt;= '0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    if (key_valid) begin\n                        debounce_counter &lt;= 1;  // Start counting\n                    end else begin\n                        debounce_counter &lt;= '0;\n                    end\n                end\n                \n                DEBOUNCE: begin\n                    if (key_valid && !debounce_done) begin\n                        debounce_counter &lt;= debounce_counter + 1;\n                    end else begin\n                        debounce_counter &lt;= '0;\n                    end\n                end\n                \n                KEY_HELD: begin\n                    if (!key_valid) begin\n                        debounce_counter &lt;= 1;  // Start release debounce\n                    end else begin\n                        debounce_counter &lt;= '0;\n                    end\n                end\n                \n                RELEASE_DEB: begin\n                    if (!key_valid && !debounce_done) begin\n                        debounce_counter &lt;= debounce_counter + 1;\n                    end else begin\n                        debounce_counter &lt;= '0;\n                    end\n                end\n                \n                default: debounce_counter &lt;= '0;\n            endcase\n        end\n    end\n    \n    // State register\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            current_state &lt;= IDLE;\n        end else begin\n            current_state &lt;= next_state;\n        end\n    end\n    \n    // Next state logic\n    always_comb begin\n        next_state = current_state;  // Default: stay in current state\n        \n        case (current_state)\n            IDLE: begin\n                if (key_valid) begin\n                    next_state = DEBOUNCE;\n                end\n            end\n            \n            DEBOUNCE: begin\n                if (!key_valid) begin\n                    next_state = IDLE;  // Glitch - go back to idle\n                end else if (debounce_done) begin\n                    next_state = KEY_HELD;  // Valid press confirmed\n                end\n            end\n            \n            KEY_HELD: begin\n                if (!key_valid) begin\n                    next_state = RELEASE_DEB;\n                end\n            end\n            \n            RELEASE_DEB: begin\n                if (key_valid) begin\n                    next_state = KEY_HELD;  // Key pressed again before full release\n                end else if (debounce_done) begin\n                    next_state = IDLE;  // Clean release confirmed\n                end\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Key code capture register\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            key_code_reg &lt;= 4'h0;\n        end else if (current_state == DEBOUNCE && debounce_done && key_valid) begin\n            // Capture key code when transitioning from DEBOUNCE to KEY_HELD\n            key_code_reg &lt;= key_code;\n        end\n    end\n    \n    // Output assignments\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            new_key_pulse &lt;= 1'b0;\n        end else begin\n            // Generate single-cycle pulse when transitioning to KEY_HELD\n            new_key_pulse &lt;= (current_state == DEBOUNCE) && \n                           (next_state == KEY_HELD) && \n                           debounce_done;\n        end\n    end\n    \n    // Captured key output is stable once registered\n    assign captured_key = key_code_reg;\n\nendmodule\nFor prompt 2, I got the following code:\nmodule keypad_scanner (\n    input  logic        clk,\n    input  logic        rst_n,\n    input  logic [3:0]  keypad_rows,    // Active-low row inputs\n    \n    output logic [3:0]  keypad_cols,    // Active-low column outputs  \n    output logic        key_valid,      // High when any key is pressed\n    output logic [3:0]  key_code        // 4-bit key code (0-F hex)\n);\n\n    // Keypad layout for reference:\n    // Cols: 0   1   2   3\n    // Row 0: 1   2   3   A\n    // Row 1: 4   5   6   B  \n    // Row 2: 7   8   9   C\n    // Row 3: *   0   #   D\n    \n    // Standard hex encoding:\n    // 1=0x1, 2=0x2, 3=0x3, A=0xA\n    // 4=0x4, 5=0x5, 6=0x6, B=0xB  \n    // 7=0x7, 8=0x8, 9=0x9, C=0xC\n    // *=0xE, 0=0x0, #=0xF, D=0xD\n\n    // Scan timing - divide main clock for column scanning\n    // For 12MHz clock, divide by 3000 gives ~4kHz scan rate (1ms per column, 4ms full cycle)\n    localparam int SCAN_DIVIDER = 3000;\n    localparam int SCAN_COUNTER_WIDTH = $clog2(SCAN_DIVIDER);\n    \n    logic [SCAN_COUNTER_WIDTH-1:0] scan_counter;\n    logic scan_tick;\n    \n    // Column state counter (2 bits for 4 columns)\n    logic [1:0] col_select;\n    \n    // Key detection and encoding\n    logic [3:0] current_key_code;\n    logic current_key_valid;\n    logic [3:0] stable_key_code;\n    logic stable_key_valid;\n    \n    // Generate scan tick - divides clock for column scanning\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            scan_counter &lt;= '0;\n            scan_tick &lt;= 1'b0;\n        end else begin\n            if (scan_counter == SCAN_DIVIDER - 1) begin\n                scan_counter &lt;= '0;\n                scan_tick &lt;= 1'b1;\n            end else begin\n                scan_counter &lt;= scan_counter + 1;\n                scan_tick &lt;= 1'b0;\n            end\n        end\n    end\n    \n    // Column selection counter - advances on scan_tick\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            col_select &lt;= 2'b00;\n        end else if (scan_tick) begin\n            col_select &lt;= col_select + 1;  // Auto-wraps at 4\n        end\n    end\n    \n    // Generate column outputs - active low, one-hot\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            keypad_cols &lt;= 4'b1111;  // All high (inactive)\n        end else begin\n            case (col_select)\n                2'b00: keypad_cols &lt;= 4'b1110;  // Column 0 active\n                2'b01: keypad_cols &lt;= 4'b1101;  // Column 1 active  \n                2'b10: keypad_cols &lt;= 4'b1011;  // Column 2 active\n                2'b11: keypad_cols &lt;= 4'b0111;  // Column 3 active\n                default: keypad_cols &lt;= 4'b1111;\n            endcase\n        end\n    end\n    \n    // Key detection and encoding logic\n    always_comb begin\n        current_key_valid = 1'b0;\n        current_key_code = 4'h0;\n        \n        // Check for key press in current column\n        // Rows are active-low, so look for 0 bits\n        case (col_select)\n            2'b00: begin // Column 0: 1, 4, 7, *\n                case (keypad_rows)\n                    4'b1110: begin current_key_valid = 1'b1; current_key_code = 4'h1; end // Row 0: '1'\n                    4'b1101: begin current_key_valid = 1'b1; current_key_code = 4'h4; end // Row 1: '4'  \n                    4'b1011: begin current_key_valid = 1'b1; current_key_code = 4'h7; end // Row 2: '7'\n                    4'b0111: begin current_key_valid = 1'b1; current_key_code = 4'hE; end // Row 3: '*'\n                    default: begin current_key_valid = 1'b0; current_key_code = 4'h0; end\n                endcase\n            end\n            \n            2'b01: begin // Column 1: 2, 5, 8, 0\n                case (keypad_rows)\n                    4'b1110: begin current_key_valid = 1'b1; current_key_code = 4'h2; end // Row 0: '2'\n                    4'b1101: begin current_key_valid = 1'b1; current_key_code = 4'h5; end // Row 1: '5'\n                    4'b1011: begin current_key_valid = 1'b1; current_key_code = 4'h8; end // Row 2: '8' \n                    4'b0111: begin current_key_valid = 1'b1; current_key_code = 4'h0; end // Row 3: '0'\n                    default: begin current_key_valid = 1'b0; current_key_code = 4'h0; end\n                endcase\n            end\n            \n            2'b10: begin // Column 2: 3, 6, 9, #\n                case (keypad_rows)\n                    4'b1110: begin current_key_valid = 1'b1; current_key_code = 4'h3; end // Row 0: '3'\n                    4'b1101: begin current_key_valid = 1'b1; current_key_code = 4'h6; end // Row 1: '6'\n                    4'b1011: begin current_key_valid = 1'b1; current_key_code = 4'h9; end // Row 2: '9'\n                    4'b0111: begin current_key_valid = 1'b1; current_key_code = 4'hF; end // Row 3: '#' \n                    default: begin current_key_valid = 1'b0; current_key_code = 4'h0; end\n                endcase\n            end\n            \n            2'b11: begin // Column 3: A, B, C, D\n                case (keypad_rows)\n                    4'b1110: begin current_key_valid = 1'b1; current_key_code = 4'hA; end // Row 0: 'A'\n                    4'b1101: begin current_key_valid = 1'b1; current_key_code = 4'hB; end // Row 1: 'B'\n                    4'b1011: begin current_key_valid = 1'b1; current_key_code = 4'hC; end // Row 2: 'C' \n                    4'b0111: begin current_key_valid = 1'b1; current_key_code = 4'hD; end // Row 3: 'D'\n                    default: begin current_key_valid = 1'b0; current_key_code = 4'h0; end\n                endcase\n            end\n            \n            default: begin\n                current_key_valid = 1'b0;\n                current_key_code = 4'h0;\n            end\n        endcase\n    end\n    \n    // Stable key output registers - hold value while key is pressed\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            stable_key_valid &lt;= 1'b0;\n            stable_key_code &lt;= 4'h0;\n        end else begin\n            if (current_key_valid) begin\n                // Key detected - capture and hold\n                stable_key_valid &lt;= 1'b1;\n                stable_key_code &lt;= current_key_code;\n            end else if (!current_key_valid && scan_tick && col_select == 2'b11) begin\n                // End of scan cycle with no key detected - clear outputs\n                stable_key_valid &lt;= 1'b0;\n                stable_key_code &lt;= 4'h0;\n            end\n            // Otherwise maintain previous values\n        end\n    end\n    \n    // Output assignments\n    assign key_valid = stable_key_valid;\n    assign key_code = stable_key_code;\n\nendmodule\nFor the top module, it gave me the following code:\nmodule keypad_top (\n    // External connections\n    input  logic [3:0]  keypad_rows,    // Active-low row inputs from keypad\n    output logic [3:0]  keypad_cols,    // Active-low column drives to keypad\n    output logic [6:0]  seg_cathodes,   // 7-segment cathodes (a-g, active-low)\n    output logic [1:0]  seg_anodes      // 7-segment anodes (digit select, active-low)\n);\n\n    // Internal oscillator instance for iCE40 UP5K (48MHz nominal)\n    logic clk_48mhz;\n    \n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b10\")  // Divide by 4: 48MHz/4 = 12MHz\n    ) u_hfosc (\n        .CLKHFPU(1'b1),     // Power up the oscillator\n        .CLKHFEN(1'b1),     // Enable the oscillator\n        .CLKHF(clk_48mhz)   // 48MHz output (before divider)\n    );\n    \n    // Main system clock (12MHz after internal divider)\n    logic clk;\n    assign clk = clk_48mhz;\n    \n    // Generate reset from power-on\n    logic [3:0] reset_counter = 4'h0;\n    logic rst_n;\n    \n    always_ff @(posedge clk) begin\n        if (reset_counter != 4'hF) begin\n            reset_counter &lt;= reset_counter + 1;\n            rst_n &lt;= 1'b0;\n        end else begin\n            rst_n &lt;= 1'b1;\n        end\n    end\n    \n    // Inter-module signals\n    logic        key_valid;\n    logic [3:0]  key_code;\n    logic        new_key_pulse;\n    logic [3:0]  captured_key;\n    \n    // Key history registers - shift register for last two keys\n    logic [3:0]  recent_key;     // Most recent key (rightmost digit)\n    logic [3:0]  older_key;      // Older key (leftmost digit)\n    \n    // Seven-segment display multiplexing\n    logic [3:0]  mux_counter;\n    logic        digit_select;   // 0 = older digit, 1 = recent digit\n    logic [3:0]  current_digit;\n    logic [6:0]  seg_data;\n    \n    // Display refresh rate: 12MHz / 4096 ≈ 2.93kHz per digit, 1.46kHz refresh rate\n    // This gives good brightness without visible flicker\n    localparam int MUX_DIVIDER = 4096;\n    localparam int MUX_COUNTER_WIDTH = $clog2(MUX_DIVIDER);\n    \n    logic [MUX_COUNTER_WIDTH-1:0] mux_div_counter;\n    logic mux_tick;\n    \n    //==========================================================================\n    // Clock divider for display multiplexing\n    //==========================================================================\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mux_div_counter &lt;= '0;\n            mux_tick &lt;= 1'b0;\n        end else begin\n            if (mux_div_counter == MUX_DIVIDER - 1) begin\n                mux_div_counter &lt;= '0;\n                mux_tick &lt;= 1'b1;\n            end else begin\n                mux_div_counter &lt;= mux_div_counter + 1;\n                mux_tick &lt;= 1'b0;\n            end\n        end\n    end\n    \n    //==========================================================================\n    // Display multiplexing logic\n    //==========================================================================\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            digit_select &lt;= 1'b0;\n        end else if (mux_tick) begin\n            digit_select &lt;= ~digit_select;  // Toggle between digits\n        end\n    end\n    \n    // Select current digit data\n    always_comb begin\n        case (digit_select)\n            1'b0: current_digit = older_key;   // Left digit (older key)\n            1'b1: current_digit = recent_key;  // Right digit (recent key)\n            default: current_digit = 4'h0;\n        endcase\n    end\n    \n    // Generate anode signals (active-low digit select)\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            seg_anodes &lt;= 2'b11;  // Both digits off\n        end else begin\n            case (digit_select)\n                1'b0: seg_anodes &lt;= 2'b10;  // Left digit on, right digit off\n                1'b1: seg_anodes &lt;= 2'b01;  // Left digit off, right digit on\n                default: seg_anodes &lt;= 2'b11;\n            endcase\n        end\n    end\n    \n    //==========================================================================\n    // Key history management\n    //==========================================================================\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            recent_key &lt;= 4'h0;\n            older_key &lt;= 4'h0;\n        end else if (new_key_pulse) begin\n            // Shift keys: older ← recent, recent ← new\n            older_key &lt;= recent_key;\n            recent_key &lt;= captured_key;\n        end\n    end\n    \n    //==========================================================================\n    // Module instantiations\n    //==========================================================================\n    \n    // Keypad scanner\n    keypad_scanner u_scanner (\n        .clk         (clk),\n        .rst_n       (rst_n),\n        .keypad_rows (keypad_rows),\n        .keypad_cols (keypad_cols),\n        .key_valid   (key_valid),\n        .key_code    (key_code)\n    );\n    \n    // One-shot key registration\n    keypad_oneshot u_oneshot (\n        .clk           (clk),\n        .rst_n         (rst_n),\n        .key_valid     (key_valid),\n        .key_code      (key_code),\n        .new_key_pulse (new_key_pulse),\n        .captured_key  (captured_key)\n    );\n    \n    // Seven-segment decoder for current digit\n    sevenSegment u_seven_seg (\n        .hex_digit (current_digit),\n        .segments  (seg_data)\n    );\n    \n    // Register seven-segment outputs for clean timing\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            seg_cathodes &lt;= 7'b1111111;  // All segments off (active-low)\n        end else begin\n            seg_cathodes &lt;= seg_data;\n        end\n    end\n\nendmodule\n\n//==========================================================================\n// Seven-segment decoder module (as referenced in the instantiation)\n//==========================================================================\nmodule sevenSegment (\n    input  logic [3:0] hex_digit,\n    output logic [6:0] segments    // {g,f,e,d,c,b,a} - active low\n);\n\n    always_comb begin\n        case (hex_digit)\n            4'h0: segments = 7'b1000000; // '0'  \n            4'h1: segments = 7'b1111001; // '1'\n            4'h2: segments = 7'b0100100; // '2'\n            4'h3: segments = 7'b0110000; // '3'\n            4'h4: segments = 7'b0011001; // '4'\n            4'h5: segments = 7'b0010010; // '5'\n            4'h6: segments = 7'b0000010; // '6'\n            4'h7: segments = 7'b1111000; // '7'\n            4'h8: segments = 7'b0000000; // '8'\n            4'h9: segments = 7'b0010000; // '9'\n            4'hA: segments = 7'b0001000; // 'A'\n            4'hB: segments = 7'b0000011; // 'b'\n            4'hC: segments = 7'b1000110; // 'C'\n            4'hD: segments = 7'b0100001; // 'd'\n            4'hE: segments = 7'b0000110; // 'E'\n            4'hF: segments = 7'b0001110; // 'F'\n            default: segments = 7'b1111111; // All off\n        endcase\n    end\n\nendmodule\n\n\nRadiant Test\nI created a new project in Radiant and it could not synthesize properly due to the error:\nError   35901063    Synthesis   ERROR &lt;35901063&gt; - c:/users/chris/onedrive/desktop/wu-e155-lab3/e155-lab3/lab3_aiprototype2/source/impl_1/keypad_top.sv(18): instantiating unknown module SB_HFOSC. VERI-1063 [keypad_top.sv:18]    \nI then changed this from SB_HFOSC to HSOSC and it was able to synthesize\n\n\n\nReflection\nI am overall very impressed with how AI performed. I learned that Claude is able to write much cleaner code than me, avoiding redundancies and having everything fit in just one module. While this is helpful here, it might not be helpful for testbenching purposes, but I think if I gave AI the right prompts, it would modify my code to make it more testbench friendly and also write the testbenches for me.\nHowever, I think that using a modular structure is much better, being able to outline the way you want your code to run and giving the AI more specific prompts can help it give you code that works well. Using a one module approach is difficult for testing and debugging, and splitting it up makes it both easier for the user and for the AI, so be able to systematically work part by part.\nWhat I learned here, is how important it is to be very precise with prompting AI. The prompts that are given to us to give to AI are very precise in terminology and what we want the AI to do, leaving no room for unnecessary misinterpretation that causes the code to not work. Thus, by giving well written prompts, we are able to get AI to give us exactly what we want and make it work.\nOnce again, I am very impressed with Claude and I can see how useful it will be for the final project."
  },
  {
    "objectID": "labs/lab3/lab3.html#hours-spent",
    "href": "labs/lab3/lab3.html#hours-spent",
    "title": "Lab 3: Keypad Scanner",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 42 hours on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "The goal of this lab is to apply our learning about interrupts to detect quadrature encoder pulses and display it as motor velocity, by using our MCU, hall effect sensors, and interrupt code."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "The goal of this lab is to apply our learning about interrupts to detect quadrature encoder pulses and display it as motor velocity, by using our MCU, hall effect sensors, and interrupt code."
  },
  {
    "objectID": "labs/lab5/lab5.html#quadrature-encoder",
    "href": "labs/lab5/lab5.html#quadrature-encoder",
    "title": "Lab 5: Interrupts",
    "section": "Quadrature Encoder",
    "text": "Quadrature Encoder\nQuadrature encoders are used to measure the angles of motors, by using two sensors that are 90 degrees apart. For our lab, we are using the 25GA370 Motor, which uses hall effect sensors and magnets to be able to detect this. To determine the speed of the motor, we can make some calculations. On the datasheet for the motor, it says that there are 408 motor Pulses Per Rotation/Revolution (PRR). We want to display the motor speed in units of revolutions per second, so we can do that by finding the pulses per second that we measure from the quadrature encoders, and divide that by the PRR. Since the sensors of the motor are 90 degrees apart, we can measure the time difference between the readings of the two sensors, and multiply that by 4 to get a full pulse. To determine how long that pulse took, we can multiply by our sampling frequency and divide that by our time difference between our two motors. The image below shows the math in more detail:"
  },
  {
    "objectID": "labs/lab5/lab5.html#mcu-design",
    "href": "labs/lab5/lab5.html#mcu-design",
    "title": "Lab 5: Interrupts",
    "section": "MCU Design",
    "text": "MCU Design\n\nObjective\nThe objective of this lab is to be able to apply our knowledge of interrupts to be able to calculate the speed of a motor, which is equipped with quadrature encoders.\n\n\nInterrupt Design\nFor the interrupts, I designed my code so that an interrupt would be triggered on a rising or falling edge of either ASIGNAL_PIN or BSIGNAL_PIN. Once the interrupt was triggered, the interrupt handler would determine which signal triggered the interrupt, and whether the value of both signals is the same. If they are the same, it would save the time difference between the two signals into deltaT. Then, it would reset the timer, and return from the interrupt. This can be seen in my interrupt design flowchart below:\n\nInterrupt Design Flowchart\n\n\n\nInterrupt Design Flowchart for Lab 5\n\n\n\n\nInterrupts vs Polling\nFor this lab, our code checks for changes in our inputs ASIGNAL_PIN and BSIGNAL_PIN very often and quickly. With code that uses polling, checking signals and processing, along with the calculations for speed are all done within the main function in the while loop, and this could lead to inaccurate or delayed outputs. This is due to the fact that we might be checking for inputs faster than our MCU can do all the processing and calculations, causing our speed outputs to not reflect the current inputs. As a result, we can use interrupts, which stop the main loop from continuously checking for new inputs until all our processing and calculations are done, ensuring that our output results are accurate and reflect the signal inputs into the MCU with no delay. The math below shows how polling will miss many clock edges if used for this lab:\n\n\n\nPolling flaws for Lab 5\n\n\n\n\n\nCode Design\nTo design with software for this lab, I utilized two different timers. I used TIM2 as my delay timer, and used TIM6 as my counter timer. For both of these timers, I used MSI as my system clock as it is the default clock running at 4 MHz. For both TIM2 and TIM6, I scaled down the timers to a slower frequency to be able to run how I wanted it.\n\nHeaders and C Files for Supporting Files\nFor this lab, we were now able to utilize the CMSIS headers, meaning that we do not have to make our own header files. For FLASH, GPIO, RCC, and USART header and c files, I took them directly from the E155 Interrupt Tutorial Repository. For the TIM file, I also took the header file from the Interrupt Tutorial Repository, but slightly modified STM32L432KC_TIM.c when initiliazing each of my timers, as I wanted them to run at different frequencies. I wanted to run my delay timer at 1 kHz for simplicity, and run my counter timer at 1 MHz due to the need to check for signals on the motor much faster and capture every edge for the highest resolution output. Thus, the code for the STM32L432KC_TIM.c file is below:\n\nTIM C File\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/30/25\n\n// Taken from the E155 Course Website and Modified\n\n// STM32F401RE_TIM.c\n// TIM functions\n\n#include \"STM32L432KC_TIM.h\"\n#include \"STM32L432KC_RCC.h\"\n\nvoid initDelayTIM(TIM_TypeDef * TIMx){\n  // Set prescaler to give 1 ms time base\n  uint32_t psc_div = (uint32_t) ((SystemCoreClock/1e3));\n\n  // Set prescaler division factor\n  TIMx-&gt;PSC = (psc_div - 1);\n  // Generate an update event to update prescaler value\n  TIMx-&gt;EGR |= 1;\n  // Enable counter\n  TIMx-&gt;CR1 |= 1; // Set CEN = 1\n}\n\nvoid initCounterTIM(TIM_TypeDef * TIMx){\n  // Set prescaler to give 1 ms time base\n  uint32_t psc_div = (uint32_t) ((SystemCoreClock/1e6));\n\n  // Set prescaler division factor\n  TIMx-&gt;PSC = (psc_div - 1);\n  // Generate an update event to update prescaler value\n  TIMx-&gt;EGR |= 1;\n  // Enable counter\n  TIMx-&gt;CR1 |= 1; // Set CEN = 1\n}\n\n\nvoid delay_millis(TIM_TypeDef * TIMx, uint32_t ms){\n  TIMx-&gt;ARR = ms;// Set timer max count\n  TIMx-&gt;EGR |= 1;     // Force update\n  TIMx-&gt;SR &= ~(0x1); // Clear UIF\n  TIMx-&gt;CNT = 0;      // Reset count\n\n  while(!(TIMx-&gt;SR & 1)); // Wait for UIF to go high\n}\n\n\n\nMain Code File\nTo tie everything together and actually run my code on the MCU, I had a main.h header file, and main.c file. I configured my timers, GPIO, and interrupts, and wrote my interrupt handling, and my speed calculations and printing. My code is as shows below:\n\nmain.h code\n// Christian Wu\n// chrwu@g.hmc.edu\n// 10/01/25\n\n// Header file for main.c\n\n#ifndef MAIN_H\n#define MAIN_H\n\n#include \"lib/STM32L432KC.h\"\n#include &lt;stm32l432xx.h&gt;\n\n#include \"lib/STM32L432KC_FLASH.h\"\n#include \"lib/STM32L432KC_GPIO.h\"\n#include \"lib/STM32L432KC_RCC.h\"\n#include \"lib/STM32L432KC_TIM.h\"\n\n#define ASIGNAL_PIN PA9\n#define BSIGNAL_PIN PA6\n#define DELAY_TIM TIM2\n#define COUNTER_TIM TIM6\n\n#endif\n\n\nmain.c code\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/30/25\n\n#include \"../lib/main.h\"\n\nint direction;\nint deltaT;\nfloat speed;\n\n// Function used by printf to send characters to the laptop - Taken from E155 Website\nint _write(int file, char *ptr, int len) {\n  int i = 0;\n  for (i = 0; i &lt; len; i++) {\n    ITM_SendChar((*ptr++));\n  }\n  return len;\n}\n\nint main(void) {\n\n    // Enable A Signal Pin\n    gpioEnable(GPIO_PORT_A);\n    pinMode(ASIGNAL_PIN, GPIO_INPUT);\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD9, 0b01); // Set PA9 as pull-up\n\n    // Enable B Signal Pin\n    pinMode(BSIGNAL_PIN, GPIO_INPUT);\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD6, 0b01); // Set PA6 as pull-up\n\n    // Initialize timer\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n    initDelayTIM(DELAY_TIM);\n\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM6EN;\n    initCounterTIM(COUNTER_TIM);\n\n    // TODO\n    // 1. Enable SYSCFG clock domain in RCC\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    // 2. Configure EXTICR for the input button interrupt\n    SYSCFG-&gt;EXTICR[2] |= _VAL2FLD(SYSCFG_EXTICR3_EXTI9, 0b000);\n    SYSCFG-&gt;EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR2_EXTI6, 0b000);\n    // Enable interrupts globally\n    __enable_irq();\n\n    // TODO: Configure interrupt for falling edge of GPIO pin for button\n    // 1. Configure mask bit\n    EXTI-&gt;IMR1 |= (1 &lt;&lt;gpioPinOffset(ASIGNAL_PIN));\n    EXTI-&gt;IMR1 |= (1 &lt;&lt;gpioPinOffset(BSIGNAL_PIN));\n    // 2. Enable rising edge trigger\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(ASIGNAL_PIN));\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(BSIGNAL_PIN));\n    // 3. Enable falling edge trigger\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(ASIGNAL_PIN));\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(BSIGNAL_PIN));\n    // 4. Turn on EXTI interrupt in NVIC_ISER\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI9_5_IRQn);\n\n    while(1){ \n        if (direction) {\n            printf(\"Direction: Clockwise \\n\");\n        } \n        else {\n            printf(\"Direction: Counter Clockwise \\n\");\n        }\n        speed = 1000000.0 / (408.0*4.0*deltaT);\n        printf(\"Speed: %f revolutions/second \\n\", speed);\n        delay_millis(DELAY_TIM, 200);\n    }\n\n}\n\n// TODO: What is the right name for the IRQHandler?\nvoid EXTI9_5_IRQHandler(void){\n    int a_reading = digitalRead(ASIGNAL_PIN);\n    int b_reading = digitalRead(BSIGNAL_PIN);\n    // Check that ASIGNAL_PIN was what triggered our interrupt\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; 9)){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; 9);\n\n        // If ASIGNAL_PIN and BSIGNAL_PIN are the same, return the difference between the two signals\n        if((a_reading && b_reading) || (!a_reading && !b_reading)) {\n            deltaT = COUNTER_TIM-&gt;CNT;\n            direction = 0;\n        }\n\n        COUNTER_TIM-&gt;CNT = 0;\n    }\n\n    // Check that BSIGNAL_PIN was what triggered our interrupt\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; 6)){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; 6);\n\n        // If ASIGNAL_PIN and BSIGNAL_PIN are the same, return the difference between the two signals\n        if((a_reading && b_reading) || (!a_reading && !b_reading)) {\n            deltaT = COUNTER_TIM-&gt;CNT;\n            direction = 1;\n        }\n\n        COUNTER_TIM-&gt;CNT = 0;\n    }\n\n}\n\n\n\n\nHardware\n\nDesign and Schematic\nI can now build my hardware and program my MCU. I am using PA6, and PA9 for my two quadrature encoder signals, onboard 5V and ground to power the quadrature encoder, and an external power supply varying from 0 to 12 V to power the motor.\nBelow, is my schematic:\n\n\n\nLab 5 Schematic\n\n\n\n\nResults\nAfter creating my Segger project and uploading the code to my MCU, I was successfully able to display the direction and speed of the motor. I was able to confirm this by using an oscilloscope to verify that my speed output was correct. To do this, I hooked up both my ASIGNAL_PIN and BSIGNAL_PIN to the oscilloscope and found the time difference between the two signals. I used a spreadsheet to convert that time difference into speed by doing the following formula: speed = 1000000 / (deltaT * 4 * PPR), where speed is in revolutions per second, deltaT is in s, and PPR was 408 pulses per revolution.\nSupplying 1.18 V to the motor, the oscilloscope showed a deltaT of 2250, which is a speed of 0.272, and my code said it was 0.262, which is a 3.7% error.\n\n\n\n1.18 Volt Oscilloscope Trace\n\n\n\n\n\n1.18 Volt MCU Reading\n\n\nSupplying 4.34 V to the motor, the oscilloscope showed a deltaT of 580, which is a speed of 1.056, and my code said it was 1.060, which is a 0.379% error.\n\n\n\n4.34 Volt Oscilloscope Trace\n\n\n\n\n\n4.34 Volt MCU Reading\n\n\nAs a result, my design and project has met all the requirements for this lab.\nSupplying 8 V to the motor, the oscilloscope showed a deltaT of 310, which is a speed of 1.977, and my code said it was 2.0, which is a 1.16% error.\n\n\n\n8 Volt Oscilloscope Trace\n\n\n\n\n\n8 Volt MCU Reading\n\n\nSupplying 12.12 V to the motor, the oscilloscope showed a deltaT of 205, which is a speed of 2.98, and my code said it was 3.08, which is a 3.36% error.\n\n\n\n12.12 Volt Oscilloscope Trace\n\n\n\n\n\n12.12 Volt MCU Reading\n\n\nAt 0 V to the motor, my MCU correctly displayed 0 revs/sec\n\n\n\n0 Volt MCU Reading\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype",
    "href": "labs/lab5/lab5.html#ai-prototype",
    "title": "Lab 5: Interrupts",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt\nTo test how AI would do for this lab, I entered the following prompt to ChatGPT:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\n\nAI Response\nAs a result, it returned the following response:\nGreat choice of MCU—this is straightforward on the L432KC.\n\nWhich pins to use\n\nYou have two good patterns depending on whether you’ll decode in software (GPIO EXTI interrupts) or offload it to a timer (hardware encoder mode). Both are easy on the NUCLEO-L432KC pinout.\n\nA) Software decode via GPIO EXTI (both edges)\n\nPick any pair that maps to distinct EXTI lines. These work well and are also on Arduino headers:\n\nPA0 → Channel A (EXTI0)\n\nPA1 → Channel B (EXTI1)\n\nAlternatives (equally good):\n\nPA6 (EXTI6) / PA7 (EXTI7)\n\nPB6 (EXTI6) / PB7 (EXTI7)\n\n(Optional index Z): PC13 (EXTI13) is perfect for the index pulse.\n\nWhy these? They give you clean EXTI lines and, if you later switch to timer encoder mode, the same pins map neatly to timer channels (see below).\n\nB) Hardware decode with a timer in Encoder Interface mode (recommended)\n\nUse a general-purpose timer with CH1/CH2 on adjacent pins:\n\nTIM2: PA0 = TIM2_CH1, PA1 = TIM2_CH2 (AF1)\n\nTIM3: PA6 = TIM3_CH1, PA7 = TIM3_CH2 (AF2)\n\nTIM4: PB6 = TIM4_CH1, PB7 = TIM4_CH2 (AF2)\n\nThis lets the timer do the A/B decoding in hardware. You can still enable a periodic/overflow interrupt or poll TIMx-&gt;CNT.\n\n\n\nReflection\nFor this prompt, AI did quite well in telling me what pins to use and why, so the hardware advice was spot on. However, it also gave me code to use, which used hardware abstraction layers (HAL). However, our approach for this lab was using CMSIS headers. I had never seen HAL before, so I also gave chatGPT my code for this lab and told it to compare between the two approaches to this lab. With this, it was able to give me good insight on the pros and cons of using each approach and how to navigate it. I think this is a strong suit of AI, as the MCU has so many tools and abilities that we have not learned about. AI is able to break down these difficult concepts in easy to digest ways with various examples. This will be really useful for the project as we work through understanding new features and how to go about it, especially with troubleshooting and setup."
  },
  {
    "objectID": "labs/lab5/lab5.html#hours-spent",
    "href": "labs/lab5/lab5.html#hours-spent",
    "title": "Lab 5: Interrupts",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 15 hours on this lab."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "The goal of this lab is to apply our learning about SPI to determine temperature at different resolutions and send it to a website using an ESP8266, which communicates and sends and receives data via USART to the MCU."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "The goal of this lab is to apply our learning about SPI to determine temperature at different resolutions and send it to a website using an ESP8266, which communicates and sends and receives data via USART to the MCU."
  },
  {
    "objectID": "labs/lab6/lab6.html#mcu-design",
    "href": "labs/lab6/lab6.html#mcu-design",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "MCU Design",
    "text": "MCU Design\n\nObjective\nThe objective of this lab is to be able to apply our knowledge of USART and SPI to communicate with new hardware and be able to send requests and receive data. We use this to control an LED and read temperature at the user’s choice on precision.\n\n\nDS1722 Temperature Sensor\nWe are using the DS1722 Temperature Sensor to gather the ambient temperature, and it communicates with our MCU via SPI. For this lab, we want to be able to control the precision of our temperature readings to be 8, 9, 10, 11, and 12 bit resolutions. To tell our temperature sensor what precision we want, we first use the MCU to send to the DS1722 the register 0x80, which is where we want to write, and then send the precision we want. Then we want to read LSB from address 0x01 and MSB from 0x02 as the temperature is sent back over 16 bits. So we use this information and convert into decimal to display. To convert our 16 bit data into a decimal temperature reading, I would convert the 8 bits of MSB into its integer number, and then check if my decimal bits are 1 or 0 and then add the corresponding decimal to my integer temperature value. Below are tables with header references and the conversion table that I used.\n\n\n\nDS1722 Register Address Structure\n\n\n\n\n\nDS1722 Temperature Data Relationships\n\n\n\n\n\nDS1722 Configuration/Status Register\n\n\n\n\nCode Design\nFor this lab, the MCU is using USART to communicate with the ESP8266 and SPI to communicate with the DS1722. The USART communication with the MCU and ESP8266 is done in my main.c file, and SPI code for DS1722 is done in a separate file.\n\nHeaders and C Files for Supporting Files\nFor this lab, we were now able to utilize the CMSIS headers, meaning that we do not have to make our own header files. For FLASH, GPIO, RCC, SPI, and USART header and c files, I took them directly from the E155 Interrupt Tutorial Repository. Below is the code for my SPI files, which includes my pins and slightly modified code:\n\nSPI Header File\n// Christian Wu\n// chrwu@g.hmc.edu\n// 10/17/25\n\n// Taken from E155 SPI Lecture\n\n// STM32L432KC_SPI.h\n// Header for SPI functions\n\n#ifndef STM32L4_SPI_H\n#define STM32L4_SPI_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stm32l432xx.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define SPI_CE PA8\n#define SPI_SCK PB3\n#define SPI_COPI PB5\n#define SPI_CIPO PB4\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\n/* Enables the SPI peripheral and intializes its clock speed (baud rate), polarity, and phase.\n *    -- br: (0b000 - 0b111). The SPI clk will be the master clock / 2^(BR+1).\n *    -- cpol: clock polarity (0: inactive state is logical 0, 1: inactive state is logical 1).\n *    -- cpha: clock phase (0: data captured on leading edge of clk and changed on next edge, \n *          1: data changed on leading edge of clk and captured on next edge)\n * Refer to the datasheet for more low-level details. */ \nvoid initSPI(int br, int cpol, int cpha);\n\n/* Transmits a character (1 byte) over SPI and returns the received character.\n *    -- send: the character to send over SPI\n *    -- return: the character received over SPI */\nchar spiSendReceive(char send);\n\n#endif\n\n\nSPI C File\n// STM32L432KC_SPI.c\n// Source code for SPI functions\n\n#include \"../lib/STM32L432KC.h\"\n#include \"../lib/STM32L432KC_SPI.h\"\n#include \"../lib/STM32L432KC_GPIO.h\"\n#include \"../lib/STM32L432KC_RCC.h\"\n\n/* Enables the SPI peripheral and intializes its clock speed (baud rate), polarity, and phase.\n *    -- br: (0b000 - 0b111). The SPI clk will be the master clock / 2^(BR+1).\n *    -- cpol: clock polarity (0: inactive state is logical 0, 1: inactive state is logical 1).\n *    -- cpha: clock phase (0: data captured on leading edge of clk and changed on next edge, \n *          1: data changed on leading edge of clk and captured on next edge)\n * Refer to the datasheet for more low-level details. */ \nvoid initSPI(int br, int cpol, int cpha) {\n    // Turn on GPIOA and GPIOB clock domains (GPIOAEN and GPIOBEN bits in AHB1ENR)\n    RCC-&gt;AHB2ENR |= (RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN);\n    \n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN; // Turn on SPI1 clock domain (SPI1EN bit in APB2ENR)\n\n    gpioEnable(GPIO_PORT_A);\n    gpioEnable(GPIO_PORT_B);\n    // Initially assigning SPI pins\n    pinMode(SPI_SCK, GPIO_ALT); // SPI1_SCK\n    pinMode(SPI_CIPO, GPIO_ALT); // SPI1_CIPO\n    pinMode(SPI_COPI, GPIO_ALT); // SPI1_COPI\n    pinMode(SPI_CE, GPIO_OUTPUT); //  Manual CS\n\n    // Set output speed type to high for SCK\n    GPIOB-&gt;OSPEEDR |= (GPIO_OSPEEDR_OSPEED3);\n\n    // Set to AF05 for SPI alternate functions\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL3, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL4, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL5, 5);\n    \n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_BR, br); // Set baud rate divider\n\n    SPI1-&gt;CR1 |= (SPI_CR1_MSTR);\n    SPI1-&gt;CR1 &= ~(SPI_CR1_CPOL | SPI_CR1_CPHA | SPI_CR1_LSBFIRST | SPI_CR1_SSM);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPHA, cpha);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPOL, cpol);\n    SPI1-&gt;CR2 |= _VAL2FLD(SPI_CR2_DS, 0b0111);\n    SPI1-&gt;CR2 |= (SPI_CR2_FRXTH | SPI_CR2_SSOE);\n\n    SPI1-&gt;CR1 |= (SPI_CR1_SPE); // Enable SPI\n}\n\n/* Transmits a character (1 byte) over SPI and returns the received character.\n *    -- send: the character to send over SPI\n *    -- return: the character received over SPI */\nchar spiSendReceive(char send) {\n    while(!(SPI1-&gt;SR & SPI_SR_TXE)); // Wait until the transmit buffer is empty\n    *(volatile char *) (&SPI1-&gt;DR) = send; // Transmit the character over SPI\n    while(!(SPI1-&gt;SR & SPI_SR_RXNE)); // Wait until data has been received\n    char rec = (volatile char) SPI1-&gt;DR;\n    return rec; // Return received character\n}\n\n\n\nDS1722 Code Files\nTo do all my temperature calculations, I did my calculations and SPI calls on separate files, shown below:\n\nDS1722.h code\n// Christian Wu \n// chrwu@g.hmc.edu\n// 10/17/2025\n\n// Header for DS1722 functions\n\n#ifndef DS1722_H\n#define DS1722_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid initTemperatureSensor(void);\n\ndouble updateTemperature(uint8_t precision);\n\n#endif\n\n\nDS1722.c Code\n// Christian Wu\n// chrwu@g.hmc.edu\n// 10/17/25\n\n// DS1722.c\n// Source code for DS1722 functions\n\n#include \"../lib/DS1722.h\"\n#include \"../lib/STM32L432KC.h\"\n#include \"../lib/STM32L432KC_GPIO.h\"\n#include \"../lib/STM32L432KC_SPI.h\"\n#include \"../lib/STM32L432KC_TIM.h\"\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\nvoid initTemperatureSensor(){\n    digitalWrite(SPI_CE, PIO_HIGH);\n    spiSendReceive(0x80);  \n    spiSendReceive(0b11100100);\n    digitalWrite(SPI_CE, PIO_LOW);\n}\n\ndouble updateTemperature(uint8_t precision){\n    digitalWrite(SPI_CE, PIO_HIGH);\n    spiSendReceive(0x80);  \n    spiSendReceive(precision);\n    digitalWrite(SPI_CE, PIO_LOW);\n\n    uint8_t lsb;\n    uint8_t msb;\n    uint8_t fracBits;\n    if (precision == 0b11100000)       // 8-bit resolution\n        fracBits = 0;\n    else if (precision == 0b11100010)  // 9-bit resolution\n        fracBits = 1;\n    else if (precision == 0b11100100)  // 10-bit resolution\n        fracBits = 2;\n    else if (precision == 0b11100110)  // 11-bit resolution\n        fracBits = 3;\n    else if (precision == 0b11101110)  // 12-bit resolution\n        fracBits = 4;\n    else\n        fracBits = 4;  // default to 12-bit\n\n\n    digitalWrite(SPI_CE, PIO_HIGH);\n    spiSendReceive(0x01);\n    lsb = spiSendReceive(0x00);\n    digitalWrite(SPI_CE, PIO_LOW);\n\n    digitalWrite(SPI_CE, PIO_HIGH);\n    spiSendReceive(0x02);\n    msb = spiSendReceive(0x00);\n    digitalWrite(SPI_CE, PIO_LOW);\n\n    bool negative = (msb & 0x80);  \n    int8_t whole = (int8_t)msb;   \n\n    \n    double frac = 0.0;\n    if (fracBits &gt;= 1 && (lsb & 0x80)) frac += 0.5;\n    if (fracBits &gt;= 2 && (lsb & 0x40)) frac += 0.25;\n    if (fracBits &gt;= 3 && (lsb & 0x20)) frac += 0.125;\n    if (fracBits &gt;= 4 && (lsb & 0x10)) frac += 0.0625;\n\n    if (negative) {\n        return (double)whole - frac;  \n    } else {\n        return (double)whole + frac; \n    }\n    }\n\n\n\nWeb Processing Code Files\nTo clean up my main file and not have complex code that is confusing on it, I moved all the web handling to a separate file and then called it in my main file.\n\nwebpage.h code\n// Christian Wu\n// chrwu@g.hmc.edu\n// 10/21/25\n\n// Header for webpage handling functions\n\n#ifndef WEBPAGE_H\n#define WEBPAGE_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stm32l432xx.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// External webpage string declarations\n///////////////////////////////////////////////////////////////////////////////\n\nextern char* webpageStart;\nextern char* ledStr;\nextern char* tempStr;\nextern char* webpageEnd;\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nint inString(char request[], char des[]);\nint updateLEDStatus(char request[], int current_status);\nvoid processWebRequest(USART_TypeDef * USART, uint8_t *precision, int *led_status);\n\n#endif\n\n\nwebpage.c file\n// Christian Wu\n// chrwu@g.hmc.edu\n// 10/21/25\n\n// Source code for webpage handling\n\n#include \"../lib/webpage.h\"\n#include \"../lib/STM32L432KC.h\"\n#include \"../lib/STM32L432KC_GPIO.h\"\n#include \"../lib/STM32L432KC_USART.h\"\n#include \"../lib/DS1722.h\"\n#include \"../lib/main.h\"\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Webpage HTML strings\n///////////////////////////////////////////////////////////////////////////////\n\nchar* webpageStart = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;E155 Web Server Demo Webpage&lt;/title&gt;\\\n    &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"&gt;\\\n    &lt;/head&gt;\\\n    &lt;body&gt;&lt;h1&gt;E155 Web Server Demo Webpage&lt;/h1&gt;\";\n\nchar* ledStr = \"&lt;p&gt;LED Control:&lt;/p&gt;&lt;form action=\\\"ledon\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED on!\\\"&gt;&lt;/form&gt;\\\n    &lt;form action=\\\"ledoff\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED off!\\\"&gt;&lt;/form&gt;\";\n\nchar* tempStr =\n\"&lt;p&gt;Temperature Precision Control:&lt;/p&gt;\"\n\"&lt;form action=\\\"8bit\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"8 Bit Resolution\\\"&gt;&lt;/form&gt;\"\n\"&lt;form action=\\\"9bit\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"9 Bit Resolution\\\"&gt;&lt;/form&gt;\"\n\"&lt;form action=\\\"10bit\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"10 Bit Resolution\\\"&gt;&lt;/form&gt;\"\n\"&lt;form action=\\\"11bit\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"11 Bit Resolution\\\"&gt;&lt;/form&gt;\"\n\"&lt;form action=\\\"12bit\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"12 Bit Resolution\\\"&gt;&lt;/form&gt;\";\n\nchar* webpageEnd = \"&lt;/body&gt;&lt;/html&gt;\";\n\n///////////////////////////////////////////////////////////////////////////////\n// Helper Functions\n///////////////////////////////////////////////////////////////////////////////\n\nint inString(char request[], char des[]) {\n    if (strstr(request, des) != NULL) {return 1;}\n    return -1;\n}\nint updateLEDStatus(char request[], int current_status)\n{\n    if (inString(request, \"ledoff\")==1) {\n        digitalWrite(LED_PIN, PIO_LOW);\n        return 0;\n    }\n    else if (inString(request, \"ledon\")==1) {\n        digitalWrite(LED_PIN, PIO_HIGH);\n        return 1;\n    }\n    return current_status;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Main Web Request Processing Function\n///////////////////////////////////////////////////////////////////////////////\n\nvoid processWebRequest(USART_TypeDef * USART, uint8_t *precision, int *led_status)\n{\n    // Receive web request from the ESP\n    char request[BUFF_LEN] = \"                  \";\n    int charIndex = 0;\n\n    // Keep going until you get end of line character\n    while(inString(request, \"\\n\") == -1) {\n        // Wait for a complete request to be transmitted before processing\n        while(!(USART-&gt;ISR & USART_ISR_RXNE));\n        request[charIndex++] = readChar(USART);\n    }\n\n    // Check for precision change requests\n    if (inString(request, \"8bit\")==1) {\n        *precision = 0b11100000;\n    }\n    else if (inString(request, \"9bit\")==1) {\n        *precision = 0b11100010;\n    }\n    else if (inString(request, \"10bit\")==1) {\n        *precision = 0b11100100;\n    }\n    else if (inString(request, \"11bit\")==1) {\n        *precision = 0b11100110;\n    }\n    else if (inString(request, \"12bit\")==1) {\n        *precision = 0b11101110;\n    }\n\n    // Read temperature with current precision\n    double temp = updateTemperature(*precision);\n\n    char tempStatusStr[32];\n    sprintf(tempStatusStr, \"Temperature %.4f C\", temp);\n\n    // Update LED status\n    *led_status = updateLEDStatus(request, *led_status);\n\n    char ledStatusStr[20];\n    if (*led_status == 1)\n        sprintf(ledStatusStr,\"LED is on!\");\n    else if (*led_status == 0)\n        sprintf(ledStatusStr,\"LED is off!\");\n\n    // Transmit the webpage over UART\n    sendString(USART, webpageStart);\n    sendString(USART, ledStr);\n    sendString(USART, tempStr);\n\n    sendString(USART, \"&lt;h2&gt;LED Status&lt;/h2&gt;\");\n    sendString(USART, \"&lt;p&gt;\");\n    sendString(USART, ledStatusStr);\n    sendString(USART, \"&lt;/p&gt;\");\n\n    sendString(USART, \"&lt;h2&gt;Temperature &lt;/h2&gt;\");\n    sendString(USART, \"&lt;p&gt;\");\n    sendString(USART, tempStatusStr);\n    sendString(USART, \"&lt;/p&gt;\");\n\n    sendString(USART, webpageEnd);\n}\n\n\n\nMain Code File\nTo tie everything together and actually run my code on the MCU, I had a main.h header file, and main.c file. My code is as shows below:\n\nmain.h code\n// Christian Wu\n// chrwu@g.hmc.edu\n// 10/17/25\n\n// Header file for main.c\n\n#ifndef MAIN_H\n#define MAIN_H\n\n#include \"STM32L432KC.h\"\n#include &lt;stm32l432xx.h&gt;\n\n#include \"STM32L432KC_FLASH.h\"\n#include \"STM32L432KC_GPIO.h\"\n#include \"STM32L432KC_RCC.h\"\n#include \"STM32L432KC_SPI.h\"\n#include \"STM32L432KC_TIM.h\"\n#include \"DS1722.h\"\n#include \"webpage.h\"\n\n#define LED_PIN PA6\n#define BUFF_LEN 32\n\n#endif\n\n\nmain.c code\n/*\nFile: main.c\nAuthor: Christian Wu\nEmail: chrwu@g.hmc.edu\nDate: 10/17/25\n*/\n\n#include \"../lib/main.h\"\n\nint main(void) {\n  configureFlash();\n  configureClock();\n\n  gpioEnable(GPIO_PORT_A);\n  gpioEnable(GPIO_PORT_B);\n  gpioEnable(GPIO_PORT_C);\n\n  pinMode(LED_PIN, GPIO_OUTPUT);\n  \n  initTIM(TIM15);\n  \n  USART_TypeDef * USART = initUSART(USART1_ID, 125000);\n\n  initSPI(0b111, 0, 1);\n  initTemperatureSensor();\n\n  int led_status = 0;\n  uint8_t precision = 0b11100100;\n\n  while(1) {\n    processWebRequest(USART, &precision, &led_status);\n  }\n}\n\n\n\n\nHardware\n\nDesign and Schematic\nI can now build my hardware and program my MCU. I am using PA6 to control my LED. For SPI, I am using PB3 for SCLK, PB4 for CIPO, PB5, for COPI, and PA8 for CE.\nBelow, is my schematic:\n\n\n\nLab 6 Schematic\n\n\n\n\nResults\nAfter creating my Segger project and uploading the code to my MCU, I was successfully able to control turning on and off the LED as well as setting my desired resolution and getting temperature readings from my DS1722 Temperature Sensor. Bellow are oscilloscope logic analyzer traces for each of the resolutions\nFor 8 bit resolution my MSB value was 19 in hex, which corresponds to 25, which is correctly displayed on my website. My LSB correctly shows 0 as I am not reading anything from it.\n\n\n\n8 Bit Resolution Logic Analyzer Trace\n\n\n\n\n\n8 Bit Resolution Website Temperature Reading\n\n\nFor 9 bit resolution my MSB value was 17 in hex, which corresponds to 23, which is correctly displayed on my website. My LSB shows 80, which means the 2-1 bit is a 1, so we add 0.5 C, giving 23.5 C.\n\n\n\n9 Bit Resolution Logic Analyzer Trace\n\n\n\n\n\n9 Bit Resolution Website Temperature Reading\n\n\nFor 10 bit resolution my MSB value was 17 in hex, which corresponds to 23, which is correctly displayed on my website. My LSB shows C0, which means the 2-1 bit is a 1, so we add 0.5 C, and the 2-2 bit is a 1, so we also add 0.25 C, giving 23.75 C.\n\n\n\n10 Bit Resolution Logic Analyzer Trace\n\n\n\n\n\n10 Bit Resolution Website Temperature Reading\n\n\nFor 10 bit resolution my MSB value was 17 in hex, which corresponds to 23, which is correctly displayed on my website. My LSB shows A0, which means the 2-1 bit is a 1, so we add 0.5 C, and the 2-3 bit is a 1, so we also add 0.125 C, giving 23.625 C.\n\n\n\n11 Bit Resolution Logic Analyzer Trace\n\n\n\n\n\n11 Bit Resolution Website Temperature Reading\n\n\nFor 12 bit resolution my MSB value was 18 in hex, which corresponds to 24, which is correctly displayed on my website. My LSB shows 10, which means the 2-4 bit is a 1, so we add 0.0625 C, giving 24.0625 C.\n\n\n\n12 Bit Resolution Logic Analyzer Trace\n\n\n\n\n\n12 Bit Resolution Website Temperature Reading\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype",
    "href": "labs/lab6/lab6.html#ai-prototype",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt\nTo test how AI would do for this lab, I entered prompts to ChatGPT, one for HTML design, and one for SPI design.\n\nHTML Prompt\nI’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\n\nAI Result\n#&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n  &lt;title&gt;Temperature Sensor Dashboard&lt;/title&gt;\n  &lt;style&gt;\n    body {\n      font-family: \"Inter\", system-ui, sans-serif;\n      background: linear-gradient(135deg, #1e293b, #0f172a);\n      color: #f1f5f9;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      height: 100vh;\n      margin: 0;\n    }\n\n    .card {\n      background: #334155;\n      border-radius: 16px;\n      padding: 2rem 3rem;\n      box-shadow: 0 8px 24px rgba(0,0,0,0.3);\n      text-align: center;\n      max-width: 400px;\n      width: 90%;\n    }\n\n    h1 {\n      margin-bottom: 1rem;\n      color: #f8fafc;\n    }\n\n    .temperature {\n      font-size: 3rem;\n      font-weight: 600;\n      margin: 1rem 0;\n      color: #38bdf8;\n    }\n\n    button {\n      background: #38bdf8;\n      color: #0f172a;\n      border: none;\n      border-radius: 8px;\n      padding: 0.75rem 1.5rem;\n      font-size: 1rem;\n      font-weight: 600;\n      cursor: pointer;\n      margin-top: 1rem;\n      transition: all 0.2s ease;\n    }\n\n    button:hover {\n      background: #0ea5e9;\n    }\n\n    .led-indicator {\n      width: 20px;\n      height: 20px;\n      border-radius: 50%;\n      margin-left: 10px;\n      display: inline-block;\n      background-color: gray;\n      vertical-align: middle;\n    }\n\n    select {\n      background: #1e293b;\n      color: #f1f5f9;\n      border: 1px solid #475569;\n      border-radius: 8px;\n      padding: 0.5rem 1rem;\n      margin-top: 1rem;\n      font-size: 1rem;\n      outline: none;\n    }\n\n    label {\n      display: block;\n      margin-top: 1rem;\n      font-weight: 500;\n      color: #e2e8f0;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=\"card\"&gt;\n    &lt;h1&gt;🌡️ Temperature Sensor&lt;/h1&gt;\n    &lt;div class=\"temperature\" id=\"tempValue\"&gt;-- °C&lt;/div&gt;\n\n    &lt;label for=\"precisionSelect\"&gt;Precision&lt;/label&gt;\n    &lt;select id=\"precisionSelect\"&gt;\n      &lt;option value=\"0.5\"&gt;0.5 °C&lt;/option&gt;\n      &lt;option value=\"0.25\"&gt;0.25 °C&lt;/option&gt;\n      &lt;option value=\"0.125\"&gt;0.125 °C&lt;/option&gt;\n      &lt;option value=\"0.0625\"&gt;0.0625 °C&lt;/option&gt;\n    &lt;/select&gt;\n\n    &lt;div style=\"margin-top: 1.5rem;\"&gt;\n      &lt;button id=\"ledToggle\"&gt;\n        Toggle LED\n        &lt;span id=\"ledIndicator\" class=\"led-indicator\"&gt;&lt;/span&gt;\n      &lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;script&gt;\n    const tempDisplay = document.getElementById('tempValue');\n    const ledButton = document.getElementById('ledToggle');\n    const ledIndicator = document.getElementById('ledIndicator');\n    const precisionSelect = document.getElementById('precisionSelect');\n\n    let ledOn = false;\n    let precision = 0.5;\n\n    // Simulate fetching data from backend\n    function fetchTemperature() {\n      // Replace with: fetch('/api/temperature')...\n      const temp = (20 + Math.random() * 5).toFixed(2);\n      tempDisplay.textContent = `${temp} °C`;\n    }\n\n    function toggleLED() {\n      ledOn = !ledOn;\n      ledIndicator.style.backgroundColor = ledOn ? '#22c55e' : 'gray';\n      // Example backend call:\n      // fetch('/api/led', { method: 'POST', body: JSON.stringify({ state: ledOn }) })\n    }\n\n    function changePrecision() {\n      precision = parseFloat(precisionSelect.value);\n      // Example backend call:\n      // fetch('/api/precision', { method: 'POST', body: JSON.stringify({ precision }) })\n      console.log(\"Precision changed to:\", precision);\n    }\n\n    ledButton.addEventListener('click', toggleLED);\n    precisionSelect.addEventListener('change', changePrecision);\n\n    // Update temperature every 2 seconds\n    setInterval(fetchTemperature, 2000);\n    fetchTemperature();\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\nSPI Prompt\n#include \"stm32l432xx.h\"\n#include &lt;stdint.h&gt;\n\n/*\n * DS1722 SPI Notes:\n *  - Temperature register is 16 bits (MSB first).\n *  - Read command for temperature register = 0x02.\n *  - The DS1722 shifts out data while you clock phantom bytes (0x00).\n *  - In 12-bit mode: upper 12 bits = temp, lower 4 bits unused.\n *  - Conversion: integer part = MSB, fractional = (LSB &gt;&gt; 4) * 0.0625°C\n */\n\n// Adjust these for your board wiring:\n#define DS1722_CS_PORT GPIOA\n#define DS1722_CS_PIN  4\n\nstatic inline void DS1722_Select(void) {\n    DS1722_CS_PORT-&gt;BSRR = (1U &lt;&lt; (DS1722_CS_PIN + 16)); // Reset bit -&gt; CS low\n}\n\nstatic inline void DS1722_Deselect(void) {\n    DS1722_CS_PORT-&gt;BSRR = (1U &lt;&lt; DS1722_CS_PIN);        // Set bit -&gt; CS high\n}\n\n// Blocking SPI helper using CMSIS\nstatic uint8_t SPI1_Transfer(uint8_t data) {\n    // Wait for TXE (Transmit buffer empty)\n    while (!(SPI1-&gt;SR & SPI_SR_TXE)) {}\n    *(volatile uint8_t *)&SPI1-&gt;DR = data;\n\n    // Wait for RXNE (Receive buffer not empty)\n    while (!(SPI1-&gt;SR & SPI_SR_RXNE)) {}\n    return *(volatile uint8_t *)&SPI1-&gt;DR;\n}\n\n// --- PUBLIC FUNCTION --- //\nfloat DS1722_ReadTemperature(void) {\n    uint8_t msb, lsb;\n    float temperature;\n\n    DS1722_Select();\n\n    // Send command byte to read temperature register\n    SPI1_Transfer(0x02);\n\n    // Read two bytes of temperature data\n    msb = SPI1_Transfer(0x00);\n    lsb = SPI1_Transfer(0x00);\n\n    DS1722_Deselect();\n\n    // Combine and convert: 12-bit reading (MSB + upper nibble of LSB)\n    int16_t rawTemp = (msb &lt;&lt; 8) | lsb;\n    rawTemp &gt;&gt;= 4; // discard lower nibble\n\n    // DS1722 outputs signed 12-bit, so sign extend if needed\n    if (rawTemp & 0x800) {\n        rawTemp |= 0xF000;  // sign extend for negative temps\n    }\n\n    temperature = rawTemp * 0.0625f; // each bit = 0.0625 °C\n\n    return temperature;\n}\n\nAI Result\n\n\n\n\nReflection\nFor this prompt, AI did really well with the HTML Design, forming a webpage that I was really visually impressed with and would implement into my project. Below is an image of what it looked like when I ran the html file on my computer.\n\n\n\nAI HTML Code Result\n\n\nFor the C code, it did not work as well, as it did not get the MSB and LSB adresses right, so it was not able to read from the right addresses. Thus, when I tried implementing this code, it was not able to run successfully. For future use of AI, I would give it the data sheet to make it more accurate and review the code myself to give the AI feedback on how to make the code be able to work."
  },
  {
    "objectID": "labs/lab6/lab6.html#hours-spent",
    "href": "labs/lab6/lab6.html#hours-spent",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 17 hours on this lab."
  },
  {
    "objectID": "labs/overview.html",
    "href": "labs/overview.html",
    "title": "Overview",
    "section": "",
    "text": "Lab 1: E155 Website Description\nLab 1: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-1-board-assembly-and-testing",
    "href": "labs/overview.html#lab-1-board-assembly-and-testing",
    "title": "Overview",
    "section": "",
    "text": "Lab 1: E155 Website Description\nLab 1: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/overview.html#lab-2-multiplexed-7-segment-display",
    "title": "Overview",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nLab 2: E155 Website Description\nLab 2: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-3-keypad-scanner",
    "href": "labs/overview.html#lab-3-keypad-scanner",
    "title": "Overview",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nLab 3: E155 Website Description\nLab 3: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-4-digital-audio",
    "href": "labs/overview.html#lab-4-digital-audio",
    "title": "Overview",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nLab 4: E155 Website Description\nLab 4: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-5-interrupts",
    "href": "labs/overview.html#lab-5-interrupts",
    "title": "Overview",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nLab 5: E155 Website Description\nLab 5: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/overview.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Overview",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\nLab 6: E155 Website Description\nLab 6: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-7-the-advanced-encryption-standard-aes",
    "href": "labs/overview.html#lab-7-the-advanced-encryption-standard-aes",
    "title": "Overview",
    "section": "Lab 7: The Advanced Encryption Standard (AES)",
    "text": "Lab 7: The Advanced Encryption Standard (AES)\nLab 7: E155 Website Description\nLab 7: Writeup"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The goal of this lab was to set up our E155 Board, soldering on all the necessary components, testing that the board functions with our FPGA and MCU, and writing code to display all hexadecimal digits on a 7-segment display and program onboard SMD LEDs"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The goal of this lab was to set up our E155 Board, soldering on all the necessary components, testing that the board functions with our FPGA and MCU, and writing code to display all hexadecimal digits on a 7-segment display and program onboard SMD LEDs"
  },
  {
    "objectID": "labs/lab1/lab1.html#board-preparation",
    "href": "labs/lab1/lab1.html#board-preparation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Board Preparation",
    "text": "Board Preparation\nTo prepare the development board for use, all the necessary components needed to be soldered on. This includes the 5V and 3.3 V Regulators, the necessary SMT Resistors, Capacitors, and Diodes, and all the necesary THT buttons, switches, and female connector pins. I followed the Interactive Development Board BOM to keep track of all the components that I soldered.\nThe parts that gave me the most trouble while soldering were the two voltage regulators, as I could not get them to adhere to the solder and stay on the board. I was not able to melt the solder while making contact with the regulator, but after a while of trial and error and guidance from Xavier, I was able to get it to work. Other than that, the rest of the components were straight forward to solder, and the step by step suggestions on the course website aided the process.\nBelow, is a picture of my fully assembled Development Board\n\n\n\nCompleted Development Board"
  },
  {
    "objectID": "labs/lab1/lab1.html#board-testing",
    "href": "labs/lab1/lab1.html#board-testing",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Board Testing",
    "text": "Board Testing\nTo test whether the board was soldered and assembled correctly, and that the FPGA and MCU are working correctly, I first followed the Lattice Radiant iCE40 UltraPlus Project Setup Tutorial. All of the setup on Radiant went smoothly, however, I had difficulty in programming onto my FPGA. On my personal laptop, the Programmer software would crash everytime I clicked the ‘detect cable button’, and on the lab computers, I would get an FTDI error when uploading code to the FPGA. I was unable to fix this issue for around 3 days, until a new programming method was uploaded (Thank you Kavi!). Thus, I followed the openFPGALoader Programmer Tutorial and was able to successfully program my FPGA. This allowed me to finish the tutorial and successfully see the onboard LED D6 at P42 blinking.\nI continued to do further testing on the FPGA as well as the MCU, I downloaded test code from the course Lab 1 Github Repo and programmed onto my board. After running the code on both my FPGA and MCU, I saw that when I had SW7 switched on, LED D3 (PA9/P25), LED D2 (PA10/P23), and LED D7 (P38) were all blinking.\nThis means that I have successfully tested by development board, FPGA, and MCU, so I know that all my components are working as expected."
  },
  {
    "objectID": "labs/lab1/lab1.html#fpga-design",
    "href": "labs/lab1/lab1.html#fpga-design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nObjective\nNow that testing the development board, FPGA, and MCU is complete, we can start working on the lab. The objective of this lab is to take inputs, s[3:0], which are the four DIP switches on SW6, and use them to drive three onboard LEDs, led[2:0], and display the hexadecimal digit of our inputs on a 7-segment display, seg[6:0]. The inputs and outputs are described by the following table:\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\ns[3:0]\ninput\nthe four DIP switches (on the board, SW6)\n\n\nled[2:0]\noutput\n3 LEDs (you may use the on-board LEDs)\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThe output of led[2] will be programmed to blink at 2.4 Hz, while the outputs of led[1:0] can be described by the following table:\n\n\n\n\ns1\ns0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\n\n\ns3\ns2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\n\n\n\nDesign\n\nBlock Diagram\nMy approach to this lab consists on three different modules. An overarching top level module called lab1_cw, which will be programmed to the board, and two submodules lab1_ledController, and lab1_sevenSegmentDisplay. The lab1_ledController submodule will control the output of each LED, utilizing the HSOSC library to control led[2], and utilizing simple logic to control led[1:0]. The lab1_sevenSegmentDisplay submodule will control the outputs on the 7-segment display, displaying the hexadecimal value provided by the dip switches, s[3:0]. The lab1_cw module will call both the lab1_ledController submodule and the lab1_sevenSegmentDisplay submodule to run on the board. Below is the block diagram I used to create this project:\n\n\n\nLab 1 Block Diagram\n\n\n\n\nLED Design\nDesign for the lab1_ledController submodule was split into two components, designing the logic for led[1:0] based on inputs s[3:0], and making led[2] blink at 2.4 Hz.\nDesigning the logic for led[1:0] was fairly simple, based on the patterns formed from the table above. Inputs s1 and s0 control the output of led[0]. From the table, led[0] is formed by an XOR gate with inputs s1 and s0.\nInputs s3 and s2 control the output of led[1]. From the table, led[1] is formed by an AND gate, with inputs s3 and s2.\nDesigning led[2] to blink at 2.4 Hz was a bit more challenging. To run at 2.4 Hz, every full cycle of the LED should be around 0.4167 seconds per cycle. Given that the LED is on or off for only half a cycle, which is also known as a 50% duty cycle, the LED needs to change state every half cycle, or every 0.2083 seconds. The HSOSC oscillator runs at 48 MHz. So in order for us to change states at every 0.2083 seconds, the clock will need to tick 10,000,000 times. This is done using a counter, which at every 10 million clock ticks of the HSOSC oscillator, will change the state of the LED from on to off or vice versa.\nBelow is the code block that was used for this submodule:\n// lab1_ledController.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls a 3-bit LED output led[2:0], which are the SMD LEDs on the motherboard.\n\nmodule lab1_ledController (\n    input logic [3:0] s,\n    output logic [2:0] led\n);\n\n// LED Logic for led[0] and led[1]\n    xor led0_logic(led[0], s[0], s[1]);\n    and led1_logic(led[1], s[2], s[3]);\n\n    // LED Logic for led[2] to blink at 2.4 Hz\n    logic int_osc;\n    logic led_state = 0;\n    logic [24:0] counter = 0;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + 1;\n            if (counter == 10_000_000) begin // Adjust this value for 2.4 Hz\n                led_state &lt;= ~led_state;\n                counter &lt;= 0;\n            end\n        end\n    //assign led[2] to blink state    \n    assign led[2] = led_state;\n\nendmodule\n\n\nSeven Segment Display Design\nDesigning the lab1_sevenSegmentDisplay submodule was fairly simple. It involved using a case statement to write out the outputs, seg[6:0] of the 7-segment display for all 16 possible inputs of s[3:0]. While writing the code, it is worth noting that turning on each segment of the 7-segment display was with a 0 output as the cathode is connected to each output pin.\nBelow is a labeled image of each segment of the 7-segment display and the code for this submodule, where s[0] is segment A and s[6] is segment G of the 7-segment display:\n\n\n\n7-segment display segment mapping\n\n\n// lab1_sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0].\nmodule lab1_sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\n\n\nTop Level Module\nGiven that this lab project was split into one top level module and two submodules, the top level module is quite simple. It is a module that calls upon the two submodules, lab1_ledController and lab1_sevenSegmentDisplay. This top level module, lab1_cw, will then be programmed onto the FPGA.\nBelow is the code for the top level module, lab1_cw:\n// lab1_cw.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,  \n// and controls a 3-bit LED output led[2:0], which are the SMD LEDs on the motherboard, \n// and a 7-segment display output seg[6:0].\nmodule lab1_cw (\n    input logic [3:0] s,\n    output logic [2:0] led,\n    output logic [6:0] seg\n);\n    // call led controller module\n    lab1_ledController led_ctrl (.s(s), .led(led));\n    // call seven segment display module\n    lab1_sevenSegmentDisplay seg_ctrl (.s(s), .seg(seg));\n\nendmodule\n\n\n\nTestbench Simulation and Testing\n\nTestbench and Test Vector Design\nTo test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench of each of my three modules. For the top level module, lab1_cw, I tested that the LED and 7-segment display outputs would be correct based on the dip switch input. For the lab1_ledController submodule, I tested just the LED outputs with the dip switch input. For the lab1_sevenSegmentDisplay submodule, I tested just the 7-segment display output with the dip switch input. For both the lab1_cw module and the lab1_ledController submodule, I omitted led[2] from the testbench and test vectors as it is blinking at 2.4 Hz.\nTo know what we are testing against, there are test vectors associated with each testbench, showing the expected outputs that will be compared against the actual outputs given by the code. To avoid redundancy, I am only attaching the top level lab1_cw test vectors testbench, as it covers what is included in the testbenches of both submodules. The testbenches for my other modules can be found in my Lab 1 GitHub Repo\nBelow are the test vectors I used for the lab1_cw_testbench:\n// lab1_cw_testvectors.tv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// Test vectors to use in my testbench file, lab1_cw_testbench.sv, \n// to simulate LED and 7 segment display\n\n// Test vector format:\n// s[3:0]_LED[1:0]_seg[6:0]\n// led[2] is excluded because it blinks at 2.4 Hz, so it will be tested on an oscilloscope\n\n0000_00_1000000\n0001_01_1111001\n0010_01_0100100\n0011_00_0110000\n0100_00_0011001\n0101_01_0010010\n0110_01_0000010\n0111_00_1111000\n1000_00_0000000\n1001_01_0010000\n1010_01_0001000\n1011_00_0000011\n1100_10_1000110\n1101_11_0100001\n1110_11_0000110\n1111_10_0001110\nBelow is the code for the testbench used for lab1_cw:\n// lab1_cw_testbench.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This is a testbench to test my lab 1 code (lab1_cw.sv).\n// It tests the LED logic and 7-segment display logic based on different 4-bit inputs.\n\n`timescale 1ns/1ns\n`default_nettype none\n`define N_TV 16\n\nmodule lab1_cw_testbench();\n\nlogic clk;\nlogic reset;\n\nlogic [3:0] s;\nlogic [2:0] led;\nlogic [1:0] led_expected;\nlogic [6:0] seg, seg_expected;\nlogic [31:0] vectornum, errors;\nlogic [12:0] testvectors[10000:0]; // s[3:0]_led[1:0]_seg[6:0]\n\n// Instantiate the device under test (DUT)\nlab1_cw dut (.s(s), .led(led), .seg(seg));\n\n// generate clock\nalways begin\n    clk = 1; #5; clk = 0; #5;\nend\n\n// Load test vectors, and pulse reset\ninitial begin\n    $readmemb(\"lab1_cw_testvectors.tv\", testvectors, 0, `N_TV-1);\n    vectornum = 0; errors = 0;\n    reset = 1; #27; reset = 0;\nend\n\n// Apply test vectors at rising edge of clock\nalways @(posedge clk) begin\n    #1; {s, led_expected, seg_expected} = testvectors[vectornum];\nend\ninitial\nbegin\n    // Create dumpfile for signals\n    $dumpfile(\"lab1_cw_testbench.vcd\");\n    $dumpvars(0, lab1_cw_testbench);\nend\n\n// Check results on falling edge of clock\nalways @(negedge clk) begin\n    if (~reset) begin\n        if (led[1:0] != led_expected || seg != seg_expected) begin\n            $display(\"Error at vector %0d: s=%b, led=%b (expected %b), seg=%b (expected %b)\", \n                     vectornum, s, led[1:0], led_expected, seg, seg_expected);\n            errors = errors + 1;\n        end\n        vectornum = vectornum + 1;\n        if (vectornum &gt;= `N_TV) begin\n            $display(\"%0d tests completed with %0d errors\", vectornum, errors);\n            $stop;\n        end\n    end\nend\nendmodule\nSomething that I had trouble with on this testbench was getting it to output the message that says the tests completed with 0 errors. When I used if (testvectors[vectornum] === 13'bx) to stop the simulation and display the message, no message would display. Thus, I checked whether vectornum reached the number of test vectors I had and would stop the simulation. This method worked, however, I want to figure out why the other method would not work.\n\n\nTestbench Results\nI was able to simulate each of my modules in Questa and it successfully worked, meaning that the outputs of my modules matched the expected output depicted by my test vectors. Below are the waveforms for each of my module’s testbenches.\n\nlab1_ledController_testbench results (only testing led[1] and led[0]):\n\n\n\nlab1_ledController Waveforms\n\n\n\n\n\nlab1_ledController Transcript\n\n\nIn addition to the testbench for the LEDs, I also used an oscilloscope to confirm that led[2] is blinking at 2.4 Hz. The oscilloscope trace can be seen below:\n\n\n\nOscilloscope trace showing led[2] blinking at 2.4 Hz\n\n\n\n\nlab1_sevenSegmentDisplay_testbench results:\n\n\n\nlab1_sevenSegmentDisplay Waveforms\n\n\n\n\n\nlab1_sevenSegmentDisplay Transcript\n\n\n\n\nlab1_cw_testbench results (top level module including LED and 7-segment display output):\n\n\n\nlab1_cw Waveforms\n\n\n\n\n\nlab1_cw Transcript\n\n\nThus, all testbenches and testing for this lab was successful!\n\n\n\n\nHardware\n\nDesign and Schematic\nAfter finishing with testing, I can now build my hardware and program my FPGA. Below, is a table of all of my pin assignments, as well as my schematic:\n\nPin assignments for Lab 1 inputs and outputs\n\n\nName\nPin\n\n\n\n\ns[0]\n37\n\n\ns[1]\n31\n\n\ns[2]\n35\n\n\ns[3]\n32\n\n\nled[0]\n28\n\n\nled[1]\n38\n\n\nled[2]\n42\n\n\nseg[0]\n10\n\n\nseg[1]\n20\n\n\nseg[2]\n13\n\n\nseg[3]\n9\n\n\nseg[4]\n6\n\n\nseg[5]\n45\n\n\nseg[6]\n47\n\n\n\n\n\n\nLab 1 Schematic\n\n\nFor the 7-segment display, resistors were added at each of the seven segment pins to prevent the display from drawing too much current. After referencing the HDSP-511A Seven Segment Display Datasheet, I found that the forward voltage for the display is 2 V. Given that we are using a 3.3 V source voltage from the FPGA, the voltage across the resistor is 1.3 V. It is safe for the 7-segment display’s pins to be around 10-20 mA, so to keep it clean, I used 100 Ohm Resistors, giving a current of 13 mA.\n\n\nResults\nAfter finishing with the design, I was able to wire my board according to the schematic and programming my top level module, lab1_cw, onto my board. Since the lab ran out of ribbon cables, I used female to male jumper cables to connect my FPGA from the development board to my breadboard. I was able to physically verify that everything worked as expected. I used the oscilloscope to confirm that led[2] was blinking at 2.4 Hz, and the 7-segment display was able to display all 16 hexadecimal inputs. led[1:0] were also able to light up as expected based on the inputs s[3:0].\nBelow are pictures demonstrating all 16 hexadecimal values on my 7-segment display:\n\n\n\n\n\n\n7-Segment Display showing 1’h0\n\n\n\n\n\n\n\n7-Segment Display showing 1’h1\n\n\n\n\n\n\n\n7-Segment Display showing 1’h2\n\n\n\n\n\n\n\n7-Segment Display showing 1’h3\n\n\n\n\n\n\n\n\n\n7-Segment Display showing 1’h4\n\n\n\n\n\n\n\n7-Segment Display showing 1’h5\n\n\n\n\n\n\n\n7-Segment Display showing 1’h6\n\n\n\n\n\n\n\n7-Segment Display showing 1’h7\n\n\n\n\n\n\n\n\n\n7-Segment Display showing 1’h8\n\n\n\n\n\n\n\n7-Segment Display showing 1’h9\n\n\n\n\n\n\n\n7-Segment Display showing 1’hA\n\n\n\n\n\n\n\n7-Segment Display showing 1’hb\n\n\n\n\n\n\n\n\n\n7-Segment Display showing 1’hC\n\n\n\n\n\n\n\n7-Segment Display showing 1’hd\n\n\n\n\n\n\n\n7-Segment Display showing 1’hE\n\n\n\n\n\n\n\n7-Segment Display showing 1’hF\n\n\n\n\n\nBelow is a picture demonstrating led[1] being on when s[3] and s[2] is on, and led[0] being on with only s[1] being on.\n\n\n\nPicture showing led[1] and led[0] on based on s[3:0] inputs\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt\nTo test how AI would do for this lab, I entered the following prompt to Claude AI:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\nAI Code\nAs a result, it returned the following code:\n// SystemVerilog LED Blinker for Lattice UP5K FPGA\n// Uses internal 48MHz oscillator to blink LED at 2Hz\n// Takes advantage of SystemVerilog features like logic, always_ff, etc.\n\nmodule led_blinker_up5k (\n    output logic led\n);\n\n    // Internal oscillator clock signal\n    logic clk_48mhz;\n    \n    // Counter for frequency division\n    // Need to divide 48MHz by 12M to get 4Hz toggle (2Hz blink)\n    // 12M = 12_000_000 requires 24 bits (2^24 = 16,777,216)\n    localparam int COUNTER_MAX = 12_000_000 - 1;\n    logic [23:0] counter;\n    \n    // LED output register\n    logic led_reg;\n    \n    // Instantiate the internal high-frequency oscillator\n    // SB_HFOSC is the Lattice UP5K primitive for the internal oscillator\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // 48MHz (divide by 1)\n    ) hfosc_inst (\n        .CLKHFPU(1'b1),     // Power up the oscillator\n        .CLKHFEN(1'b1),     // Enable the oscillator\n        .CLKHF(clk_48mhz)   // 48MHz clock output\n    );\n    \n    // Counter logic using SystemVerilog always_ff\n    always_ff @(posedge clk_48mhz) begin\n        if (counter &gt;= COUNTER_MAX) begin\n            counter &lt;= '0;\n            led_reg &lt;= ~led_reg;  // Toggle LED every 0.25 seconds\n        end else begin\n            counter &lt;= counter + 1'b1;\n        end\n    end\n    \n    // Assign LED output\n    assign led = led_reg;\n\nendmodule\n\n\nTest in Radiant\nI then started a new project in Radiant and attempted to synthesize the code. It was unable to synthesize due to the following error:\nERROR &lt;35901063&gt; - c:/users/chris/onedrive/desktop/wu-e155-lab1/lab1_cw_aiprototype/source/impl_1/led_blinker_up5k.sv(29): instantiating unknown module SB_HFOSC. VERI-1063\n\nchild process exited abnormally\nDone: error code 1\nClaude AI proceded to make some changes but after synthesizing, it still returned the same error.\n\n\nReflection\nAfter comparing my code to the one that Claude produced, I was able to see the potential of coding with AI. Claude got everything in the module correct with the exception of the HSOSC part. Although this is the most important part and Claude got it wrong, it was very close to being right, and small tweaks and guidance in the right direction on to properly use the HSOSC library would result in code that would work.\nI like how clean the syntax of Claude is, and the variable names are informative. The added comments are also quite helpful to understand the logic and structure of the code. With some support on the library, coding with an AI can be very powerful, as it is able to do the bulk of the work for us quickly and efficiently. Small tweaks for more nuanced things like specific libraries is a reasonable fix for me and an easy one to do, to be able to take advantage of the power of AI for the rest of the code. To do this, I could either change the code manually, or create more specific prompts to tell it how to use the library in a way that will work.\nOverall, I am very impressed with how well it worked, and I see a lot of potential for it to be used for the final project."
  },
  {
    "objectID": "labs/lab1/lab1.html#hours-spent",
    "href": "labs/lab1/lab1.html#hours-spent",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 24 hours on this lab."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "",
    "text": "The goal of this lab is to use our FPGA as a hardware accelerator to perform AES-128 encryption with plaintext and key provided by our MCU."
  },
  {
    "objectID": "labs/lab7/lab7.html#introduction",
    "href": "labs/lab7/lab7.html#introduction",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "",
    "text": "The goal of this lab is to use our FPGA as a hardware accelerator to perform AES-128 encryption with plaintext and key provided by our MCU."
  },
  {
    "objectID": "labs/lab7/lab7.html#mcu-design",
    "href": "labs/lab7/lab7.html#mcu-design",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "MCU Design",
    "text": "MCU Design\nAll of the MCU Code was provided for this lab from the E155 Lab 7 Starter Code Repository. Thus, the work done for this lab was for building the FPGA hardware accelerator below."
  },
  {
    "objectID": "labs/lab7/lab7.html#fpga-design",
    "href": "labs/lab7/lab7.html#fpga-design",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nObjective\nThe objective of this lab is to use SPI to send a plaintext and key from our MCU to our FPGA, use our FPGA as a hardware accelerator to do AES-128 encryption, and then send the encrypted ciphertext back to the MCU via SPI.\n\n\nDesign\n\nAES Encryption\nThe encryption method we are using is AES-128 according to the NIST FIPS-197 specification. For this lab, I will be creating it by following the following pseudocode:\n\n\n\nFIPS-197 Encryption Pseudocode\n\n\nFor the key expansion module, I will be following the pseudocode below:\n\n\n\nFIPS-197 keyExpansion Pseudocode\n\n\nThe logic for each of the modules that I write can be found in the NIST FIPS-197 documentation.\n\n\nBlock Diagram\nMy approach for this lab was to have a module for each of the sections of the NIST FIPS-197 documentation. The top level aes.sv module uses the onboard HSOSC 48 MHz clock and receives the key and plaintext via SPI from the MCU and then does the encryption. Then it sends the encrypted ciphertext back to the MCU via SPI. Belows is my block diagram for this lab:\n\n\n\nLab 7 Block Diagram\n\n\n\n\nAES Core FSM\n\nFSM Overview\nThe AES core FSM was designed with 9 states (S0-S8) to implement the AES-128 encryption algorithm according to FIPS-197. The FSM orchestrates the encryption process through an initial round, 9 regular rounds, and a final round, accounting for the pipeline delays introduced by synchronous S-box lookups.\n\nDesign Rationale\nThe state machine accounts for pipeline delays from synchronous operations: - SubBytes delay: 1 cycle (sbox_sync uses block RAM) - KeyExpansion delay: 2 cycles total (1 for subWord sbox, 1 for final register)\nThese delays necessitate wait states between operations to ensure data is ready before proceeding. The design prioritizes correctness and synchronization over speed, completing full AES-128 encryption in 11 clock cycles (including the load cycle).\n\n\nState Utilization\nCurrently using 4 bits of state representation for 9 states, leaving 7 unused states. This is acceptable because: - Clear state encoding improves debuggability - Minimal hardware cost for extra flip-flops - Could potentially optimize to 3 bits (since 2³ = 8 &lt; 9 &lt; 16 = 2⁴), but would need special handling\n\n\n\nFSM State Transition Diagram\n\n\n\naes_core FSM State Transition Diagram\n\n\n\n\nState Transition Table\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition\nNext State\nDescription\n\n\n\n\nS0\nAlways\nS1\nInitial AddRoundKey complete, SubBytes starts\n\n\nS1\nAlways\nS2\nWait 1 cycle for SubBytes (sbox_sync)\n\n\nS2\nAlways\nS3\nWait 1 cycle for KeyExpansion (subWord sbox)\n\n\nS3\nAlways\nS4\nWait 1 cycle for key register\n\n\nS4\nround &lt; 9\nS1\nContinue to next regular round (rounds 1-9)\n\n\nS4\nround == 9\nS5\nMove to final round (round 10)\n\n\nS5\nAlways\nS6\nFinal SubBytes starts\n\n\nS6\nAlways\nS7\nWait for final key expansion\n\n\nS7\nAlways\nS8\nFinal AddRoundKey complete\n\n\nS8\nAlways\nS8\nStay in done state\n\n\n\n\n\nOutput Control Tables\n\nState Actions\n\n\n\n\n\n\n\n\nState\nActions\nNotes\n\n\n\n\nS0\ncurrentState &lt;= addRoundKeyDone\nCapture initial AddRoundKey result\n\n\nS1\n(none)\nWait for SubBytes pipeline\n\n\nS2\n(none)\nWait for KeyExpansion pipeline\n\n\nS3\n(none)\nWait for key register pipeline\n\n\nS4\ncurrentKey &lt;= keyExpansionDonecurrentState &lt;= addRoundKeyDoneif (round == 9) savedFinalKey &lt;= keyExpansionDoneif (round &lt; 9) round++\nCapture expanded key and stateSave round-10 key when finishing round 9Increment round counter\n\n\nS5\nfinalLeftReg &lt;= shiftRowsDone\nSave ShiftRows output (skip MixColumns)\n\n\nS6\n(none)\nWait for final key expansion\n\n\nS7\ncurrentState &lt;= addRoundKeyDone\nFinal AddRoundKey result\n\n\nS8\ndone &lt;= 1\nAssert done signal\n\n\n\n\n\nDatapath Multiplexer Controls\nbypassMuxResult (input to AddRoundKey)\n\n\n\nState\nMux Output\nPurpose\n\n\n\n\nS0\nplainTextState\nInitial round uses plaintext\n\n\nS4\nmixColumnsDone\nRegular rounds include MixColumns\n\n\nS7\nfinalLeftReg\nFinal round skips MixColumns\n\n\nOther\ncurrentState\nDefault (maintain state)\n\n\n\nkeyMuxOut (key input to AddRoundKey)\n\n\n\nState\nMux Output\nPurpose\n\n\n\n\nS0\ninitialKeyState\nUse original cipher key\n\n\nS7\nfinalKeyState\nUse saved round-10 key\n\n\nOther\nkeyState\nUse current expanded key\n\n\n\n\n\n\n\n\nTestbench Simulation and Testing\n\nTestbench Design and Results\nTo test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench for each of my modules, testing a different functionality of this lab with east testbench. Due to the large number of modules that I have in this lab, I am not posting the code in this writeup, but each testbench can be found in my Lab 7 Github Repo.\nEach of the testbenches were done by using the stim/assert method or checking if the outputs match the expected value, to ensure functionality automatically, without having to analyze the waveforms carefully to see if it worked or not.\n\naddRoundKey_tb results:\n\n\n\naddRoundKey Waveforms\n\n\n\n\n\naddRoundKey Transcript\n\n\n\n\naes_core_tb results:\nThis testbench tests if encryption works correctly.\n\n\n\naes_core Waveforms\n\n\n\n\n\naes_core Transcript\n\n\n\n\naes_sbox_tb results:\nThis testbench demonstrates 1-cycle latency of RAM blocks doing s-box substitution\n\n\n\naes_sbox_tb Waveforms\n\n\n\n\naes_spi results:\nThis testbench tests encryption with SPI functionality.\n\n\n\naes_spi Waveforms\n\n\n\n\n\naes_spi Transcript\n\n\n\n\ngaloismult_tb results:\n\n\n\ngaloismult Waveforms\n\n\n\n\n\ngaloismult Transcript\n\n\n\n\ninput2State_tb results:\n\n\n\ninput2State Waveforms\n\n\n\n\n\ninput2State Transcript\n\n\n\n\nkeyExpansion_tb results:\n\n\n\nkeyExpansion Waveforms\n\n\n\n\n\nkeyExpansion Transcript\n\n\n\n\nmixcolumn_tb results:\n\n\n\nmixcolumn Waveforms\n\n\n\n\n\nmixcolumn Transcript\n\n\n\n\nmixcolumns_tb results:\n\n\n\nmixcolumns Waveforms\n\n\n\n\n\nmixcolumns Transcript\n\n\n\n\nrotWord_tb results:\n\n\n\nrotWord_tb Waveforms\n\n\n\n\n\nrotWord_tb Transcript\n\n\n\n\nsbox_tb results:\nThis testbench tests the non synchronized sbox module\n\n\n\nsbox Waveforms\n\n\n\n\n\nsbox Transcript\n\n\n\n\nshiftRows_tb results:\n\n\n\nshiftRows Waveforms\n\n\n\n\n\nshiftRows Transcript\n\n\n\n\nstate2Output_tb results:\n\n\n\nstate2Output Waveforms\n\n\n\n\n\nstate2Output Transcript\n\n\n\n\nsubBytes_tb results:\n\n\n\nsubBytes Waveforms\n\n\n\n\n\nsubBytes Transcript\n\n\n\n\nsubWord_tb results:\n\n\n\nsubWord Waveforms\n\n\n\n\n\nsubWord Transcript\n\n\nThus, all testbenches and testing for this lab was successful!\n\n\n\n\nHardware\n\nDesign and Schematic\nAfter finishing with testing, I can now build my hardware and program my FPGA and MCU. Our E155 Development board has onboard SPI connections for SPI between the FPGA and MCU, so we do not need to use any breadboarding. Thus, a schematic is not necessary. Below are all the pins we are using.\n\nPin assignments for Lab 7 inputs and outputs\n\n\nName\nMCU Pin\nFPGA Pin\n\n\n\n\nCE\nPA11\n—\n\n\nSCK\nPB3\nP21\n\n\nCIPO\nPB4\nP12\n\n\nCOPI\nPB5\nP10\n\n\nLOAD\nPA5\nP26\n\n\nDONE\nPA6\nP27\n\n\nSUCCESS_LED\nPA9\n—\n\n\nFAIL_LED\nPA10\n—\n\n\n\n\n\nResults\nAfter finishing with the design, I was able to program my FPGA and MCU. I used a logic analyzer to confirm that the SPI transaction worked correctly.\nBelow is the Logic Analyzer SPI Transaction:\n\n\n\nLogic Analyzer SPI Transaction\n\n\nWithin my logic analyzer transaction, I can also confirm that I have the correct values for my plaintext, key, and ciphertext. Below are logic analyzer pictures for the first four values of each:\n\n\n\nFirst two values of Plaintext\n\n\n\n\n\nThird and fourth values of Plaintext\n\n\n\n\n\nFirst two values of key\n\n\n\n\n\nThird and fourth values of key\n\n\n\n\n\nFirst two values of ciphertext\n\n\n\n\n\nThird and fourth values of ciphertext\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab7/lab7.html#ai-prototype",
    "href": "labs/lab7/lab7.html#ai-prototype",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt 1\nTo test how AI would do for this lab, I entered the following prompt to ChatGPT:\nWrite SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.\n\nAI Code\nAs a result, it returned the following code:\n// -----------------------------------------------------------------------------\n// AES-128 KeyExpansion (next round key)\n// Combinational: next_key = KeyExpansion(prev_key, round_num)\n// References: FIPS-197 §5.2 KEYEXPANSION(), Alg.2; Table 5 (Rcon)\n// Assumptions:\n//   - prev_key layout: {w0, w1, w2, w3} with w0 at [127:96] and w3 at [31:0]\n//   - Round numbers are 1..10 for AES-128.\n//   - Modules RotWord and SubWord exist and are purely combinational:\n//       module RotWord(input  logic [31:0] in, output logic [31:0] out);\n//       module SubWord(input  logic [31:0] in, output logic [31:0] out);\n// -----------------------------------------------------------------------------\nmodule AesKeyExpansion128 (\n    input  logic [127:0] prev_key,     // previous round key (K_round)\n    input  logic  [3:0]  round_num,    // 1..10\n    output logic [127:0] next_key      // next round key (K_round+1)\n);\n    // Split previous 128-bit key into 4 words\n    logic [31:0] w0, w1, w2, w3;\n    assign {w0, w1, w2, w3} = prev_key;\n\n    // Temp = SubWord(RotWord(w3)) ^ Rcon[round_num]  (FIPS-197 §5.2)\n    logic [31:0] rotw, subw, rcon, temp;\n\n    RotWord u_rot (.in(w3), .out(rotw));\n    SubWord u_sub (.in(rotw), .out(subw));\n\n    // Round constants Rcon[j] = {rc,00,00,00} for j=1..10 (Table 5)\n    function automatic logic [31:0] rcon_lut(input logic [3:0] j);\n        unique case (j)\n            4'd1:  rcon_lut = 32'h01_00_00_00;\n            4'd2:  rcon_lut = 32'h02_00_00_00;\n            4'd3:  rcon_lut = 32'h04_00_00_00;\n            4'd4:  rcon_lut = 32'h08_00_00_00;\n            4'd5:  rcon_lut = 32'h10_00_00_00;\n            4'd6:  rcon_lut = 32'h20_00_00_00;\n            4'd7:  rcon_lut = 32'h40_00_00_00;\n            4'd8:  rcon_lut = 32'h80_00_00_00;\n            4'd9:  rcon_lut = 32'h1B_00_00_00;\n            4'd10: rcon_lut = 32'h36_00_00_00;\n            default: rcon_lut = 32'h00_00_00_00; // safe default\n        endcase\n    endfunction\n\n    assign rcon = rcon_lut(round_num);\n    assign temp = subw ^ rcon;\n\n    // Next words (AES-128):\n    //  w4 = w0 ^ temp\n    //  w5 = w1 ^ w4\n    //  w6 = w2 ^ w5\n    //  w7 = w3 ^ w6\n    logic [31:0] nw0, nw1, nw2, nw3;\n    assign nw0 = w0 ^ temp;\n    assign nw1 = w1 ^ nw0;\n    assign nw2 = w2 ^ nw1;\n    assign nw3 = w3 ^ nw2;\n\n    assign next_key = {nw0, nw1, nw2, nw3};\nendmodule\n\n\nTest in Questa\nI tried to fix the code and run my testbench, but I could not get the testbench to run as one of the inputs is the round number not the rcon value, and for my code, I have it so that my aes_core file calculates rcon based on the round number and feeds it into keyEpxansion.\n\n\n\nCannot run testbench on AI Result\n\n\n\n\n\nModular Prompts\nI then ran the second prompt by the pseudocode. I used the following prompt:\nWrite SystemVerilog HDL to implement the following logic:\n\ni = 0\nwhile i &lt; Nk do\n    w[i] &lt;- key[4*i..4*i+3]\n    i &lt;- i+1\nend while\nwhile i &lt;= 4 * Nr + 3 do\n    temp &lt;- w[i-1]\n    if i mod Nk = 0 then\n        temp &lt;- module1(module2(temp)) (+) Rcon[i/Nk]\n    else if Nk &gt; 6 and i mod Nk = 4 then\n        temp &lt;- module1(temp)\n    end if\n    w[i] &lt;- w[i-Nk] (+) temp\n    i &lt;- i + 1\nend while\nreturn w\nAssume module1 and module2 are existing modules that can be instantiated. (+) refers to XOR. Unwrap the loop in the provided pseudo code so it uses the previous iterations output to generate the new iteration.\n\nDo not use any existing knowledge of the AES specifications in your answer.\n\nAI Code Result\nChatGPT gave me the following code.\n// ------------------------------------------------------------\n// Key-like expansion (fully combinational, loop \"unrolled\")\n// Mirrors the provided pseudo-code without using any AES spec.\n//\n// PSEUDO (for reference):\n// i = 0\n// while i &lt; Nk do\n//   w[i] &lt;- key[4*i..4*i+3]\n//   i &lt;- i+1\n// end while\n// while i &lt;= 4 * Nr + 3 do\n//   temp &lt;- w[i-1]\n//   if i mod Nk = 0 then\n//       temp &lt;- module1(module2(temp)) (+) Rcon[i/Nk]\n//   else if Nk &gt; 6 and i mod Nk = 4 then\n//       temp &lt;- module1(temp)\n//   end if\n//   w[i] &lt;- w[i-Nk] (+) temp\n//   i &lt;- i + 1\n// end while\n// return w\n// ------------------------------------------------------------\n\nmodule keyExpansion #(\n    parameter int NK = 4,          // number of initial key words\n    parameter int NR = 10          // used to size total output words\n) (\n    // Initial key as words: key_words[i] corresponds to key[4*i .. 4*i+3]\n    input logic clk,\n    input  logic [31:0] key_words [0:NK-1],\n\n    // Rcon array: only entries actually used are those at indices i/NK\n    // for i in [NK .. (4*NR+3)], when (i % NK) == 0.\n    // Size it to at least ( (4*NR+3) / NK ).\n    input  logic [31:0] rcon      [0:((4*NR+3)/NK)],\n\n    // Expanded words w[0 .. 4*NR+3]\n    output logic [31:0] w         [0:(4*NR+3)]\n);\n\n    // Total number of output words\n    localparam int WORDS = 4*NR + 4;\n\n    // Internal wire array for the chain\n    logic [31:0] w_int [0:WORDS-1];\n\n    // ---- First segment: copy initial key words ----\n    genvar k;\n    generate\n        for (k = 0; k &lt; NK; k++) begin : INIT\n            // w[k] &lt;- key[4*k .. 4*k+3]\n            assign w_int[k] = key_words[k];\n        end\n    endgenerate\n\n    // ---- Second segment: generate remaining words, unrolled ----\n    // For each i in [NK .. WORDS-1], compute per the pseudo-code.\n    genvar i;\n    generate\n        for (i = NK; i &lt; WORDS; i++) begin : EXPAND\n            // temp &lt;- w[i-1] (base)\n            wire [31:0] base_temp = w_int[i-1];\n\n            // Parallel evaluations needed for conditional paths:\n            //   A) module1(module2(temp))\n            //   B) module1(temp)\n            // We build both and select by static conditions below.\n            wire [31:0] m2_out;\n            wire [31:0] m1_after_m2_out;\n            wire [31:0] m1_direct_out;\n\n            // Instantiate module2 for this step (input is base_temp)\n            rotWord u_m2 (\n                base_temp,\n                m2_out\n            );\n\n            // module1 on module2(base_temp)\n             subWord u_m1_after_m2 (\n                m2_out,\n                m1_after_m2_out\n            );\n\n            // module1 on base_temp\n            subWord u_m1_direct (\n                base_temp,\n                m1_direct_out\n            );\n\n            // Static (elaboration-time) conditions for this unrolled index i:\n            localparam bit COND_ROT   = ((i % NK) == 0);             // i mod Nk = 0\n            localparam bit COND_ONLY1 = ((NK &gt; 6) && ((i % NK) == 4)); // Nk &gt; 6 and i mod Nk = 4\n\n            // Select temp per pseudo-code:\n            // if (i % Nk == 0)              temp &lt;- module1(module2(temp)) XOR Rcon[i/Nk]\n            // else if (Nk &gt; 6 && i%Nk == 4) temp &lt;- module1(temp)\n            // else                           temp &lt;- base_temp\n            wire [31:0] temp_selected = (COND_ROT)   ? (m1_after_m2_out ^ rcon[i / NK]) :\n                                        (COND_ONLY1) ?  m1_direct_out :\n                                                        base_temp;\n\n            // w[i] &lt;- w[i-Nk] XOR temp\n            assign w_int[i] = w_int[i - NK] ^ temp_selected;\n        end\n    endgenerate\n\n    // Drive outputs\n    genvar j;\n    generate\n        for (j = 0; j &lt; WORDS; j++) begin : OUTS\n            assign w[j] = w_int[j];\n        end\n    endgenerate\n\nendmodule\n\n\nRadiant Test\nI fixed my testbench and made some code changes and ran the testbench but it did not pass the testbench. Below is a screenshot of the waveforms and the transcript.\n\n\n\nAI Prompt 2 Testbench Results\n\n\n\n\n\nReflection\nFor this lab, AI did not work too well. When using pseudocode by itself, ChatGPT was lost and produced very poor outputs. For the first prompt where we attached the NIST specification it had a lot more potential with the ride code tweaks and prompt changes, but ultimately was not where I wanted it to be. None of the code was able to pass testbenches, but continued prompting to tweak the code could have helped make it better and fix it. I was surprised that it did not work, maybe due to the complexity of the NIST FIPS-197 specification."
  },
  {
    "objectID": "labs/lab7/lab7.html#hours-spent",
    "href": "labs/lab7/lab7.html#hours-spent",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "",
    "text": "The goal of this lab is to implement a time-multiplexer to drive two seven segment displays with a single set of FPGA I/O pins, using a transistor circuit to drive large currents from our FPGA to our dual seven-segment display, to output the hexadecimal numbers of two dip switches. There will also be five LEDs on the breadboard, which will display the sum of the two input values."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "",
    "text": "The goal of this lab is to implement a time-multiplexer to drive two seven segment displays with a single set of FPGA I/O pins, using a transistor circuit to drive large currents from our FPGA to our dual seven-segment display, to output the hexadecimal numbers of two dip switches. There will also be five LEDs on the breadboard, which will display the sum of the two input values."
  },
  {
    "objectID": "labs/lab2/lab2.html#fpga-design",
    "href": "labs/lab2/lab2.html#fpga-design",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nObjective\nThe objective of this lab is to use System Verilog to code a time-multiplexer to run both halves of my dual seven-segment display by switching between turning on the common anode of each display so that the naked eye cannot see the flickering of the two displays. To be able to supply the large current needed by the display, 2N3906 PNP transistors will be used. We will also use an adder to sum the two hexadecimal inputs from our dip switches and display that on five LEDs.\n\n\nDesign\n\nBlock Diagram\nMy approach to this lab consists on five different modules. It was designed to have many modules to make testing the functionality of each function of this lab easily. An overarching top level module called lab2_cw, which will be programmed to the board, and four submodules adder, sevenSegmentDisplay, timeMultiplexer, and sevenSegMux. The adder submodule will give the 5 bit sum of two four bit inputs, so that we can show the sum of our two inputs on five LEDS. The sevenSegmentDisplay submodule is the same one that was used in Lab 1, which will control the outputs on the 7-segment display, displaying the hexadecimal value provided by the dip switches, s1[3:0] and s2[3:0]. The timeMultiplexer submodule is responsible for controlling which common anode gets turned on in the dual 7-segment display. It was designed to switch at 500 Hz, which should be high enough to not be noticeable to the human eye. It will also output a signal to guide which input should be used by the sevenSegmentDisplay module, which is controlled by sevenSegMux. The sevenSegMux module is a mux that controls which four bit input will be fed into sevenSegmentDisplay based on the enable, signal, which is given by timeMultiplexer. The top level lab2_cw calls upon all these submodules as well as the HSOSC submodule, which takes advantage of the onboard 48 MHz clock on the FPGA. Below is the block diagram I used to create this project:\n\n\n\nLab 2 Block Diagram\n\n\n\n\nAdder Design\nThe adder submodule was a very simple design. It simply consisted of combinational logic that produced a 5 bit output, sum, from two four bit inputs, a and b.\nBelow is the code block that was used for this submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module is a 4-bit adder that takes in two 4-bit inputs a and b, and outputs a 5-bit sum.\nmodule adder (\n    input logic [3:0] a, b,\n    output logic [4:0] sum);\n\n    always_comb begin\n        sum = a + b;\n    end\nendmodule\n\n\nSeven Segment Display Design\nThis submodule is coopied from Lab 1 and uses the exact same code. Designing the sevenSegmentDisplay submodule was fairly simple. It involved using a case statement to write out the outputs, seg[6:0] of the 7-segment display for all 16 possible inputs of s[3:0]. While writing the code, it is worth noting that turning on each segment of the 7-segment display was with a 0 output as the cathode is connected to each output pin.\nBelow is a labeled image of each segment of the 7-segment display and the code for this submodule, where s[0] is segment A and s[6] is segment G of the 7-segment display:\n\n\n\n7-segment display segment mapping\n\n\n// sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0].\nmodule lab1_sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\n\n\nTime Multiplexer Design\nThe main purpose of the timeMultiplexer submodule is to switch between each common anode on our dual 7-segment display, so that we only need one sevenSegmentDisplay submodule to control both digits. Thus, we are turning on one side of the dual 7-segment display on at a time, but if we do it fast enough, the human eye cannot notice each digit turning on and off. To switch between the two common anodes fast enough, I chose to switch between each display at 500 Hz. This is done by using the FPGA’s onboard 48 MHz clock, and using a counter. 500 Hz is equivalent to 0.002 seconds per cycle, and assuming a 50% duty cycle, we must switch from one common anode to the other every 0.001 seconds. For a 48 MHz clock, this would equate to 48000 ticks. Thus, we can use a counter to turn each side of the dual 7-segment display on or off, every 48000 ticks. At the same time, we can also output, signal, to tell the sevenSegMux submodule, which input to display on the corresponding side of the dual 7-segment display\nBelow is the code for the timeMultiplexer submodule:\n//  timeMultiplexer.sv\n//  Christian Wu\n//  chrwu@g.hmc.edu\n//  09/06/25\n\n// This module takes in two four bit inputs, s1 and s2, and switches between them to drive a dual seven\n// segment display, to utilize only one sevenSegmentDisplay module. The switching is done at a rate fast enough\n// such that the human eye cannot detect the switching, and it appears that both displays are on at the same time.\n\nmodule timeMultiplexer (\n    input clk,\n    output logic an1, an2,\n    output logic signal);\n\n    logic [24:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        counter &lt;= counter + 1;\n        if (counter == 48000) begin\n            counter &lt;= 0;\n            signal &lt;= ~signal; \n            if (~signal) begin\n                an1 &lt;= 1; // turn off an1\n                an2 &lt;= 0; // turn on an2\n            end else begin\n                an1 &lt;= 0; // turn on an1\n                an2 &lt;= 1; // turn off an2\n            end\n\n    end\n    end\nendmodule\n\n\nSeven Segment Mux Design\nThe design for the sevenSegMux submodule is quite simple. This submodule depicts a simple mux with an enable on it. This submodule is used to output the correct 4 bit input into the sevenSegmentDisplay submodule. When the enable is on, we set the ouput to be s2, and when it is off, we set the output to be s1.\nBelow is the code for the sevenSegMux submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module takes in two 4-bit inputs, s1 and s2, and an enable, and outputs one \n// of the inputs to a 4-bit output based on the enable signal for the seven-segment display\n\nmodule sevenSegMux (\n    input logic [3:0] s1, s2,\n    input logic enable,\n    output logic [3:0] out);\n\n    always_comb begin\n        if (enable) begin\n            out = s2;\n        end else begin\n            out = s1;\n        end\n    end\nendmodule\n\n\nTop Level Module\nGiven that this lab project was split into one top level module and four submodules, the top level module is quite simple. It is a module that calls upon the four submodules, adder, sevenSegmentDisplay, timeMultiplexer, and sevenSegMux. It also calls upon the HSOSC module to take advantage of the onboard 48 MHz clock on the FPGA. This top level module, lab2_cw, will then be programmed onto the FPGA.\nBelow is the code for the top level module, lab2_cw:\n// lab2_cw.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module is the top level module for lab 2. It instantiates the timeMultiplexer module to drive the\n// seven-segment display, and connects the dip switches to the inputs of the timeMultiplexer module. It also displays\n// the sum of the two 4-bit inputs on five LEDs.\n\nmodule lab2_cw (\n    input logic [3:0] s1, s2, // dip switches\n    output logic [6:0] seg, // seven-segment display\n    output logic an1, an2, // anodes for the two displays\n    output logic [4:0] sum); // 5 LEDs to display sum\n\n    \n    logic [3:0] sevenSegmentSignal;\n    logic signal; // select signal to choose between s1 and s2\n    logic clk;\n    \n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\n    timeMultiplexer tm (.clk(clk), .an1(an1), .an2(an2), .signal(signal));\n    sevenSegMux ssm (.s1(s1[3:0]), .s2(s2[3:0]), .enable(signal), .out(sevenSegmentSignal));\n    sevenSegmentDisplay ssd (.s(sevenSegmentSignal), .seg(seg));\n    adder a (.a(s1[3:0]), .b(s2[3:0]), .sum(sum[4:0]));\nendmodule\n\n\n\nTestbench Simulation and Testing\n\nTestbench Design and Results\nTo test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench for each of my five modules, testing a different functionality of this lab with east testbench. For the adder submodule, I tested all 256 possible cases using a for loop to make sure that the output sum was correct. For the sevenSegmentDisplay submodule, I tested all 16 possible 4 bit inputs and made sure that the 7 bit output was correct. For the timeMultiplexer submodule, I tested the sequential logic that occurs in this submodule to check that the submodule switches between turning on each common anode on the dual 7-segment display, and correctly outputs the right signal for the sevenSegMux to use. For the sevenSegMux submodule, I tested that the mux would output the right 4 bit value from the two 4 bit inputs, based on whether the enable was on or off. For the top level lab2_cw module, it was used to test that the HSOSC module worked, by sampling a few different test cases and making sure that the dual 7-segment display would show both of the values by switching between outputting each one.\nEach of the testbenches were done by using the stim/assert method, to ensure functionality automatically, without having to analyze the waveforms carefully to see if it worked or not.\n\nadder_testbench results:\nThis testbench tested the combinational logic of the adder submodule, testing all 256 cases. Below is the code used for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the 4-bit adder module by providing various test cases and checking the output.\n`timescale 1ns/1ps\n\nmodule adder_testbench();\n    logic [3:0] a, b;\n    logic [4:0] sum;\n    logic [4:0] expected_sum;\n    adder dut (.a(a), .b(b), .sum(sum));\n\n    integer i,j;\n    integer test_cases = 0;\n\n    initial begin\n        // Test all combinations of 4-bit inputs\n        for (i = 0; i &lt; 16; i++) begin\n            for (j = 0; j &lt; 16; j++) begin\n                a = i[3:0];\n                b = j[3:0];\n                #1; // wait for combinational logic to settle\n                test_cases++;\n                expected_sum = a + b;\n                assert (sum === expected_sum)\n                    else $error(\"ASSERTION FAILED: a=%0d, b=%0d, expected sum=%0d, got sum=%0d\", a, b, expected_sum, sum);\n            end\n        end\n\n        $display(\"All %0d test cases completed with\", test_cases);\n        $stop;\n    end\nendmodule\nBelow are the Questa simulation results:\n\n\n\nadder Waveforms\n\n\n\n\n\nadder Transcript\n\n\n\n\nsevenSegmentDisplay_testbench results:\nThis testbench tested the combinational logic of the sevenSegmentDisplay submodule, testing all 16 cases. Below is the code used for my testbench:\n// sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0]. This module is copy and pasted from lab 1\nmodule sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\nBelow are the results of the Questa simulation of this testbench:\n\n\n\nsevenSegmentDisplay Waveforms\n\n\n\n\n\nsevenSegmentDisplay Transcript\n\n\n\n\ntimeMultiplexer_testbench results:\nThis testbench tested the sequential logic of switching between turning on each common anode, and outputting the right signal for the sevenSegmentMux submodule. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the timeMultiplexer module by simulating clock cycles and checking if the an1, an2, and signal outputs\n// toggle correctly based on the internal counter.\n\n// timeMultiplexer_simple_tb.sv\n// Simple testbench focusing only on an1 and an2 switching behavior\n\n`timescale 1ns / 1ps\n\nmodule timeMultiplexer_testbench();\n    logic clk;\n    logic an1, an2;\n    logic signal;\n    \n    timeMultiplexer dut (.clk(clk), .an1(an1), .an2(an2), .signal(signal));\n    \n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; \n    end\n    \n    // Test sequence\n    initial begin\n        repeat(10) begin\n            @(posedge signal or negedge signal);\n            #1;\n        end\n        \n        $display(\"Test completed successfully.\");\n        $stop;\n    end\n    \n    // Assert statements for anode behavior\n    always @(*) begin\n        // Assert anodes are always opposite (mutually exclusive)\n        assert (an1 !== an2)\n        else $error(\"Anodes not mutually exclusive: an1=%b, an2=%b\", an1, an2);\n        \n        // Assert correct anode control based on signal\n        assert (signal ? (an1 == 1 && an2 == 0) : (an1 == 0 && an2 == 1))\n        else $error(\"Incorrect anode control: signal=%b, an1=%b, an2=%b\", signal, an1, an2);\n        \n        // Assert only one display is active at a time (one anode is 0)\n        assert ((an1 == 0) ^ (an2 == 0))\n        else $error(\"Neither or both displays active: an1=%b, an2=%b\", an1, an2);\n    end\n    \nendmodule\nI also used an oscilloscope to confirm that the switching between the two sides of the dual 7-segment display is at 500 Hz:\n\n\n\nOscilloscope trace switching displays at 500 Hz\n\n\nBelow are the Questa simulation results:\n\n\n\ntimeMultiplexer Waveforms\n\n\n\n\n\ntimeMultiplexer Transcript\n\n\n\n\nsevenSegMux_testbench results:\nThis testbench tested that the mux worked as expected, testing all 512 cases. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the sevenSegMux module by inputing all combinations of s1, s2, and enable signals\n// and checking if the output is as expected.\n\n`timescale 1ns/1ps\n\nmodule sevenSegMux_testbench();\n    logic [3:0] s1, s2;\n    logic enable;\n    logic [3:0] out;\n    sevenSegMux dut (.s1(s1), .s2(s2), .enable(enable), .out(out));\n\n    integer i, j;\n    integer errors = 0;\n    integer test_cases = 0;\n    logic [3:0] expected_out;\n\n    initial begin\n        // Test all combinations of 4-bit inputs and enable signal\n        for (i = 0; i &lt; 16; i++) begin\n            for (j = 0; j &lt; 16; j++) begin\n                s1 = i[3:0];\n                s2 = j[3:0];\n\n                // Test with enable = 0\n                enable = 0;\n                #10; \n                test_cases++;\n                expected_out = s1;\n                assert (out === expected_out)\n                    else $error(\"ASSERTION FAILED: s1=%0d, s2=%0d, enable=0, expected out=%0d, got out=%0d\", s1, s2, expected_out, out);\n\n                // Test with enable = 1\n                enable = 1;\n                #10; \n                test_cases++;\n                expected_out = s2;\n                assert (out === expected_out)\n                    else $error(\"ASSERTION FAILED: s1=%0d, s2=%0d, enable=1, expected out=%0d, got out=%0d\", s1, s2, expected_out, out);\n            end\n        end\n\n        $display(\"All %0d test cases successfully completed.\", test_cases);\n        $stop;\n    end\n    endmodule\nBelow are the Questa simulation results:\n\n\n\nsevenSegMux Waveforms\n\n\n\n\n\nsevenSegMux Transcript\n\n\n\n\nlab2_cw_testbench results:\nThis testbench tested the HSOSC module and the overall functionality of this lab by using a few sample test cases. Below is the code for my testbench:\n// lab2_cw_testbench.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// Simple testbench for lab2_cw module - tests each case one at a time\n\n`timescale 1ns / 1ps\n\nmodule lab2_cw_testbench;\n    logic [3:0] s1, s2;\n    logic [6:0] seg;\n    logic [6:0] expected_seg;\n    logic an1, an2;\n    logic [4:0] sum;\n    logic [4:0] expected_sum;\n    \n    logic [6:0] seg_patterns [16] = {\n        7'b1000000, // 0\n        7'b1111001, // 1\n        7'b0100100, // 2\n        7'b0110000, // 3\n        7'b0011001, // 4\n        7'b0010010, // 5\n        7'b0000010, // 6\n        7'b1111000, // 7\n        7'b0000000, // 8\n        7'b0010000, // 9\n        7'b0001000, // A\n        7'b0000011, // b\n        7'b1000110, // C\n        7'b0100001, // d\n        7'b0000110, // E\n        7'b0001110  // F\n    };\n    \n    // Instantiate the Device Under Test (DUT)\n    lab2_cw dut (.s1(s1), .s2(s2), .seg(seg), .an1(an1), .an2(an2), .sum(sum));\n    \n    initial begin\n        // Test Case 1: 0 + 0 = 0\n        s1 = 4'h0;\n        s2 = 4'h0;\n        expected_sum = 5'd0;\n        #2000000; // Wait 2ms for display to switch (500Hz = 2ms period)\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        // Wait for display 1 to be active (an1 = 0)\n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        // Wait for display 2 to be active (an2 = 0) \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 2: 5 + 3 = 8\n        s1 = 4'h5;\n        s2 = 4'h3;\n        expected_sum = 5'd8;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 3: A + 7 = 17\n        s1 = 4'hA;\n        s2 = 4'h7;\n        expected_sum = 5'd17;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 4: F + F = 30 (maximum)\n        s1 = 4'hF;\n        s2 = 4'hF;\n        expected_sum = 5'd30;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 5: 8 + 8 = 16\n        s1 = 4'h8;\n        s2 = 4'h8;\n        expected_sum = 5'd16;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        $display(\"All tests successfully completed.\");\n        $stop;\n    end\n    \nendmodule\nBelow are my Questa simulation results:\n\n\n\nlab2_cw Waveforms\n\n\n\n\n\nlab2_cw Transcript\n\n\nThus, all testbenches and testing for this lab was successful!\n\n\n\n\nHardware\n\nDesign and Schematic\nAfter finishing with testing, I can now build my hardware and program my FPGA. Below, is a table of all of my pin assignments, as well as my schematic:\n\nPin assignments for Lab 2 inputs and outputs\n\n\nName\nPin\n\n\n\n\ns1[0]\n37\n\n\ns1[1]\n31\n\n\ns1[2]\n35\n\n\ns1[3]\n32\n\n\ns2[0]\n44\n\n\ns2[1]\n3\n\n\ns2[2]\n45\n\n\ns2[3]\n46\n\n\nled[0]\n20\n\n\nled[1]\n12\n\n\nled[2]\n13\n\n\nled[3]\n18\n\n\nled[4]\n9\n\n\nan1\n10\n\n\nan2\n2\n\n\nseg[0]\n21\n\n\nseg[1]\n19\n\n\nseg[2]\n11\n\n\nseg[3]\n6\n\n\nseg[4]\n4\n\n\nseg[5]\n48\n\n\nseg[6]\n47\n\n\n\n\n\n\nLab 2 Schematic\n\n\nDual 7-segment Display Resistor Values\nFor the 7-segment display, resistors were added at each of the seven segment pins to prevent the display from drawing too much current. After referencing the HDSP-521A Seven Segment Display Datasheet, I found that the forward voltage for the display is 2 V. Given that we are using a 3.3 V source voltage from the FPGA, the voltage across the resistor is 1.3 V. It is safe for the 7-segment display’s pins to be around 10-20 mA, so to keep it clean, I used 100 Ohm Resistors, giving a current of 13 mA.\n2N3906 Transistor Base Resistor Value\nWe are supplying 3.3 V to our 2N3906 PNP Transistor. We know from the data sheetthat the Base Emitter Voltage is around 0.7, so we have 2.6 V that will be dropped through the resistor that connects the base to the GPIO Pin. From the iice40 Datasheet, we know from Table 4.17 that I_OL = 8 mA. Thus, we know that we want the current to be between 1 and 8 mA. I chose to use a 1 k Ohm resistor, which gives a current of 2.6 mA, giving ample wiggle room on both ends. Below is a picture that models this math:\n\n\n\nTransistor Resistor Value Math\n\n\nLED Resistor Values\nThe forward voltage of our yellow LEDs is around 2V, and we know that the current through the LEDs should be under 20 mA. Given that we are supplying 3.3 V, the remaining voltage drop across our resistor would be 1.3 V. I chose to use a 100 Ohm resistor, which gives me a current of 13 mA, keeping the LED bright, but under the 20 mA max.\n\n\nResults\nAfter finishing with the design, I was able to wire my board according to the schematic and programming my top level module, lab2_cw, onto my board. I was able to physically verify that everything worked as expected.\nBelow are a few pictures demonstrating this lab working successfully:\n\n\n\ns1 = 6; s2 = 3; sum = 9\n\n\n\n\n\ns1 = F; s2 = 8; sum = 23\n\n\n\n\n\ns1 = 0; s2 = 5; sum = 5\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt 1\nTo test how AI would do for this lab, I entered the following prompt to Claude AI:\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nAI Code\nAs a result, it returned the following code:\n// Time-multiplexed seven segment decoder for two displays\n// Common anode seven segment display driver\nmodule seven_seg_decoder_mux (\n    input  logic        clk,           // Clock input\n    input  logic        rst_n,         // Active-low reset\n    input  logic [3:0]  digit0_in,     // First 4-bit input\n    input  logic [3:0]  digit1_in,     // Second 4-bit input\n    output logic [6:0]  seg0_out,      // Seven segment output for display 0 (a-g)\n    output logic [6:0]  seg1_out,      // Seven segment output for display 1 (a-g)\n    output logic        digit0_enable, // Enable signal for display 0\n    output logic        digit1_enable  // Enable signal for display 1\n);\n\n    // Internal signals\n    logic [3:0] mux_input;     // Multiplexed input to decoder\n    logic [6:0] decoded_seg;   // Output from seven segment decoder\n    logic       mux_select;    // Multiplexer select signal\n    logic [6:0] seg0_reg;      // Registered output for display 0\n    logic [6:0] seg1_reg;      // Registered output for display 1\n    \n    // Clock divider for multiplexing (adjust counter width for desired refresh rate)\n    // With a typical 50MHz clock, this gives ~763Hz refresh per display\n    logic [15:0] clk_counter;\n    \n    // Clock divider and multiplexer select generation\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_counter &lt;= 16'd0;\n            mux_select &lt;= 1'b0;\n        end else begin\n            clk_counter &lt;= clk_counter + 1;\n            // Toggle mux_select at MSB of counter\n            mux_select &lt;= clk_counter[15];\n        end\n    end\n    \n    // Input multiplexer\n    always_comb begin\n        case (mux_select)\n            1'b0: mux_input = digit0_in;\n            1'b1: mux_input = digit1_in;\n        endcase\n    end\n    \n    // Seven segment decoder (common anode - active low outputs)\n    // Segments: a=bit6, b=bit5, c=bit4, d=bit3, e=bit2, f=bit1, g=bit0\n    always_comb begin\n        case (mux_input)\n            4'h0: decoded_seg = 7'b1000000; // 0\n            4'h1: decoded_seg = 7'b1111001; // 1\n            4'h2: decoded_seg = 7'b0100100; // 2\n            4'h3: decoded_seg = 7'b0110000; // 3\n            4'h4: decoded_seg = 7'b0011001; // 4\n            4'h5: decoded_seg = 7'b0010010; // 5\n            4'h6: decoded_seg = 7'b0000010; // 6\n            4'h7: decoded_seg = 7'b1111000; // 7\n            4'h8: decoded_seg = 7'b0000000; // 8\n            4'h9: decoded_seg = 7'b0010000; // 9\n            4'hA: decoded_seg = 7'b0001000; // A\n            4'hB: decoded_seg = 7'b0000011; // b\n            4'hC: decoded_seg = 7'b1000110; // C\n            4'hD: decoded_seg = 7'b0100001; // d\n            4'hE: decoded_seg = 7'b0000110; // E\n            4'hF: decoded_seg = 7'b0001110; // F\n        endcase\n    end\n    \n    // Output registers - capture decoded value when corresponding digit is selected\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            seg0_reg &lt;= 7'b1111111; // All segments off (common anode)\n            seg1_reg &lt;= 7'b1111111;\n        end else begin\n            if (mux_select == 1'b0) begin\n                seg0_reg &lt;= decoded_seg;\n            end else begin\n                seg1_reg &lt;= decoded_seg;\n            end\n        end\n    end\n    \n    // Output assignments\n    assign seg0_out = seg0_reg;\n    assign seg1_out = seg1_reg;\n    \n    // Generate enable signals (active low for common anode displays)\n    // Only one display is enabled at a time for time multiplexing\n    assign digit0_enable = ~mux_select;  // Active when mux_select = 0\n    assign digit1_enable = mux_select;   // Active when mux_select = 1\n\nendmodule\n\n\nTest in Radiant\nI then started a new project in Radiant and attempted to synthesize the code. Claude was able to synthesize properly and it seems like it would actually work quite well, which is really impressive. By slightly modifying this code and adapting it for the purposes of this lab, it would be able to work successfully.\n\n\n\nPrompt 2\nI then ran the second prompt by also giving my lab 1 files as a sample to base off of. I used the following prompt:\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nAI Code Result\nClaude gave me the following code.\nmodule timemux_sevenSegmentDisplay (\n    input logic [3:0] input_a,    // First 4-bit input\n    input logic [3:0] input_b,    // Second 4-bit input\n    output logic [6:0] seg,       // Common seven segment output\n    output logic enable_a,        // Enable signal for display A (active low)\n    output logic enable_b         // Enable signal for display B (active low)\n);\n\n    // Internal signals\n    logic int_osc;\n    logic mux_select = 0;\n    logic [20:0] counter = 0;\n    logic [3:0] current_input;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Clock divider for multiplexing frequency\n    always_ff @(posedge int_osc) begin\n        counter &lt;= counter + 1;\n        if (counter == 24_000) begin  // 1kHz multiplex frequency\n            mux_select &lt;= ~mux_select;\n            counter &lt;= 0;\n        end\n    end\n    \n    // Input multiplexer\n    always_comb begin\n        if (mux_select)\n            current_input = input_b;\n        else\n            current_input = input_a;\n    end\n    \n    // Generate enable signals (active low for common anode displays)\n    assign enable_a = mux_select;   // Active when mux_select is 0\n    assign enable_b = ~mux_select;  // Active when mux_select is 1\n    \n    // Instantiate the seven segment decoder\n    lab1_sevenSegmentDisplay decoder (\n        .s(current_input),\n        .seg(seg)\n    );\n\nendmodule\n\n\nRadiant Test\nI created a new project in Radiant and was able to get the code to successfully synthesize. I also assigned pins and programmed the code onto my board and it worked successfully.\n\n\n\nReflection\nI am overall very impressed with how AI performed. I was able to run the code on my board and get it to work as expected, showing the power of using AI to write quick and effective code. I learned that Claude is able to write much cleaner code than me, avoiding redundancies and having everything fit in just one module. While this is helpful here, it might not be helpful for testbenching purposes, but I think if I gave AI the right prompts, it would modify my code to make it more testbench friendly and also write the testbenches for me.\nWhat I learned here, as well as with the AI prototype of Lab 1 is that if we guide the AI to where we want it to be, it will be able to achieve what we want. If we don’t guide it at all, it will do a fairly good job, but it won’t work and it won’t be perfect. But if we guide it in the right direction, it will be able to correct those small details that are wrong and be able to run correctly on the board.\nOnce again, I am very impressed with Claude and I can see how useful it will be for the final project."
  },
  {
    "objectID": "labs/lab2/lab2.html#hours-spent",
    "href": "labs/lab2/lab2.html#hours-spent",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 15 hours on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "The goal of this lab is to use our STM32L432KC to drive audio on a speaker and be able to play music. This will be done using an LM386 audio amplifier and a potentiometer to control the volume, as well as software using C."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "The goal of this lab is to use our STM32L432KC to drive audio on a speaker and be able to play music. This will be done using an LM386 audio amplifier and a potentiometer to control the volume, as well as software using C."
  },
  {
    "objectID": "labs/lab4/lab4.html#mcu-design",
    "href": "labs/lab4/lab4.html#mcu-design",
    "title": "Lab 4: Digital Audio",
    "section": "MCU Design",
    "text": "MCU Design\n\nObjective\nThe objective of this lab is to understand how to read the STM32L432KC to drive different clocks and play different frequencies of sound on our MCU. Using the data sheet to understand how to drive our MCU is key here.\n\n\nDesign\nTo design with software for this lab, I utilized two different timers. I used TIM16 due to its PWM functionality to output the correct frequency, and used TIM6, due to its simple design to set a delay between when the frequencies should be switched to play the notes for the right amount of time. For both of these timers, I used MSI as my system clock as it is the default clock running at 4 MHz. For both TIM16 and TIM6, I scaled down the timers to a slower frequency to be able to run the range of frequencies that I wanted, and the range of delays that I wanted.\n\nHeaders\nTo be able to utilize the TIM16 and TIM6 timers, I needed to create header files to include the memory locations of each register. For RCC, FLASH, GPIO, I used the preexisting ones provided in class. The TIM16 and TIM6 header files are as shown below:\n\nTIM16 Header File\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/19/25\n\n// STM32L432KC_TIM16.h\n// Header for TIM16 functions\n\n#ifndef STM32L4_TIM16_H\n#define STM32L4_TIM16_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses for GPIO ports\n#define TIM16_BASE (0x40014400) // base address of TIM16\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\ntypedef struct {\n  __IO uint32_t TIM16_CR1;      /*!&lt; TIM16 control register 1,              Address offset: 0x00 */\n  __IO uint32_t TIM16_CR2;      /*!&lt; TIM16 control register 2,              Address offset: 0x04 */\n  uint32_t      RESERVED0;      /*!&lt; Reserved,                              Address offset: 0x08 */\n  __IO uint32_t TIM16_DIER;     /*!&lt; TIM16 DMA/Interrupt Enable Register,   Address offset: 0x0C */\n  __IO uint32_t TIM16_SR;       /*!&lt; TIM16 Status Register,                 Address offset: 0x10 */\n  __IO uint32_t TIM16_EGR;      /*!&lt; TIM16 Event Generation Register,       Address offset: 0x14 */\n  __IO uint32_t TIM16_CCMR1;    /*!&lt; TIM16 Capture/Compare Mode Register 1, Address offset: 0x18 */\n  uint32_t      RESERVED1;      /*!&lt; Reserved,                              Address offset: 0x1C */\n  __IO uint32_t TIM16_CCER;     /*!&lt; TIM16 Capture/Compare Enable Register, Address offset: 0x20 */\n  __IO uint32_t TIM16_CNT;      /*!&lt; TIM16 Counter,                         Address offset: 0x24 */\n  __IO uint32_t TIM16_PSC;      /*!&lt; TIM16 Prescaler,                       Address offset: 0x28 */\n  __IO uint32_t TIM16_ARR;      /*!&lt; TIM16 Auto-Reload Register,            Address offset: 0x2C */\n  __IO uint32_t TIM16_RCR;      /*!&lt; TIM16 Repetition Counter Register,     Address offset: 0x30 */\n  __IO uint32_t TIM16_CCR1;     /*!&lt; TIM16 Capture/Compare Register 1,      Address offset: 0x34 */\n  uint32_t      RESERVED2;      /*!&lt; Reserved,                              Address offset: 0x38 */\n  uint32_t      RESERVED3;      /*!&lt; Reserved,                              Address offset: 0x3C */\n  uint32_t      RESERVED4;      /*!&lt; Reserved,                              Address offset: 0x40 */\n  __IO uint32_t TIM16_BDTR;     /*!&lt; TIM16 Break and Dead-Time Register,    Address offset: 0x44 */\n  __IO uint32_t TIM16_DCR;      /*!&lt; TIM16 DMA Control Register,            Address offset: 0x48 */\n  __IO uint32_t TIM16_DMAR;     /*!&lt; TIM16 DMA Address For Full Transfer,   Address offset: 0x4C */\n  __IO uint32_t TIM16_OR1;      /*!&lt; TIM16 Option Register 1,               Address offset: 0x50 */\n  uint32_t      RESERVED5;      /*!&lt; Reserved,                              Address offset: 0x54 */\n  uint32_t      RESERVED6;      /*!&lt; Reserved,                              Address offset: 0x58 */\n  uint32_t      RESERVED7;      /*!&lt; Reserved,                              Address offset: 0x5C */\n  __IO uint32_t TIM16_OR2;      /*!&lt; TIM16 Option Register 2,               Address offset: 0x60 */\n} TIM16_TypeDef;\n\n#define TIM16 ((TIM16_TypeDef *) TIM16_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configureTIM16();\n\nvoid setPWM(int frequency, int dutyCycle);\n\n#endif\n\n\nTIM 6 Header File\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/19/25\n\n// STM32L432KC_TIM6.h\n// Header for TIM6 functions\n\n#ifndef STM32L4_TIM6_H\n#define STM32L4_TIM6_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses for GPIO ports\n#define TIM6_BASE (0x40001000UL) // base address of TIM6\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\ntypedef struct {\n  __IO uint32_t TIM6_CR1;       /*!&lt; TIM6 control register 1,               Address offset: 0x00 */\n  __IO uint32_t TIM6_CR2;       /*!&lt; TIM6 control register 2,               Address offset: 0x04 */\n  uint32_t      RESERVED0;      /*!&lt; Reserved,                              Address offset: 0x08 */\n  __IO uint32_t TIM6_DIER;      /*!&lt; TIM6 DMA/Interrupt Enable Register,    Address offset: 0x0C */\n  __IO uint32_t TIM6_SR;        /*!&lt; TIM6 Status Register,                  Address offset: 0x10 */\n  __IO uint32_t TIM6_EGR;       /*!&lt; TIM6 Event Generation Register,        Address offset: 0x14 */\n  uint32_t      RESERVED1;      /*!&lt; Reserved,                              Address offset: 0x18 */\n  uint32_t      RESERVED2;      /*!&lt; Reserved,                              Address offset: 0x1C */\n  uint32_t      RESERVED3;      /*!&lt; Reserved,                              Address offset: 0x20 */\n  __IO uint32_t TIM6_CNT;       /*!&lt; TIM6 Counter,                          Address offset: 0x24 */\n  __IO uint32_t TIM6_PSC;       /*!&lt; TIM6 Prescaler,                        Address offset: 0x28 */\n  __IO uint32_t TIM6_ARR;       /*!&lt; TIM6 Auto-Reload Register,             Address offset: 0x2C */\n  \n} TIM6_TypeDef;\n\n#define TIM6 ((TIM6_TypeDef *) TIM6_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configureTIM6();\n\nvoid setDelay(int ms);\n\n#endif\n\n\n\nTIM16 Design\nFor TIM16, I wanted to run it at 1 MHz, so I set the prescaler to 3. This is because $CK_{CNT} = f_{CK_PSC} / ( + 1), so \\(CK_{CNT}\\) = 4 MHz / (3 + 1) = 1 MHz. The reason for the plus one is because it takes one clock tick for the counter to start after setting the CEN bit in the CR1 register. Below is a screenshot from the reference manual to show this:\n\n\n\nCounter starts one clock tick after setting CEN bit in TIMx_CR1 register\n\n\nTo obtain the right frequency to output, we need to set a value of ARR. ARR correlates to the output frequency in the following way: \\(f_{out} = f_{in} / (\\text{ARR} + 1)\\). Thus, we can solve for ARR based on our desired frequency: \\(\\text{ARR} = (1000000 / f_{desired}) - 1\\). Thus, I can now calculate my maximum and minimum frequencies. We know from the reference manual that ARR ranges between 0 and 65535, as it is a 16 bit register:\nThus, we can calculate the maximum and minimum supported frequencies\n\n\n\nMaximum and Minimum supported output frequencies\n\n\nTo actually play the frequencies, I created a setPWM function, which took in inputs of frequency and duty cycle. The code for TIM16 is below:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/19/25\n\n// Code to utilize TIM16 for PWM\n\n#include \"../lib/STM32L432KC_TIM16.h\"\n#include \"../lib/STM32L432KC_RCC.h\"\n\nvoid configureTIM16() {\n    \n    // Set Clock to 4 MHz\n    // Enable GPIO A\n    RCC-&gt;AHB2ENR |= (1 &lt;&lt; 0);\n    // Enable TIM16\n    RCC-&gt;APB2ENR |= (1 &lt;&lt; 17);\n\n    // Use prescaler to set clock to 1 MHz in TIM16_PSC\n    TIM16-&gt;TIM16_PSC = 3;\n\n    // Set Auto Reload Register in TIM16_ARR\n    TIM16-&gt;TIM16_ARR = 0xFFFF;\n\n    // Set PWM Mode in TIM16_CCMR1\n    TIM16-&gt;TIM16_CCMR1 &= ~(0b111 &lt;&lt; 4);  // Clear OC1M[6:4] bits\n    TIM16-&gt;TIM16_CCMR1 |= (0b110 &lt;&lt; 4);   // Set PWM Mode 1 (110)\n    TIM16-&gt;TIM16_CCMR1 |= (1 &lt;&lt; 3);       // Set OC1PE (preload enable)\n    TIM16-&gt;TIM16_CCMR1 &= ~(0b11 &lt;&lt; 0);   // Clear CC1S (output mode)\n\n    // Set the auto-reload preload enable in TIM16_CR1\n    TIM16-&gt;TIM16_CR1 |= (1 &lt;&lt; 7);\n\n    // Set output enable in TIM16_CCER\n    TIM16-&gt;TIM16_CCER |= (1 &lt;&lt; 0);\n\n    // Set main output enable in TIM16_BDTR\n    TIM16-&gt;TIM16_BDTR |= (1 &lt;&lt; 15);\n\n    // Set Capture/compare register in TIM16_CCR1\n    TIM16-&gt;TIM16_CCR1 = 0;\n\n    // Set update generation bit in TIM16_EGR\n    TIM16-&gt;TIM16_EGR |= (1 &lt;&lt; 0);\n\n    // Set timer counter enable in TIM16_CR1\n    TIM16-&gt;TIM16_CR1 |= (1 &lt;&lt; 0);\n}\n\nvoid setPWM(int frequency, int dutyCycle) {\n\n    // Set ARR values as a variable\n    uint32_t arr_value = (1000000 / frequency) - 1;\n    // Set ARR in TIM16_ARR\n    TIM16-&gt;TIM16_ARR = arr_value;\n    \n    // Set Duty Cycle in TIM16_CCR1\n    TIM16-&gt;TIM16_CCR1 = (arr_value + 1) * dutyCycle/100;\n\n    // Set update generation bit in TIM16_EGR\n    TIM16-&gt;TIM16_EGR |= (1 &lt;&lt; 0);\n}\n\n\nTIM6 Design\nI used TIM6 for its simplicity to create a delay in milliseconds. This would determine when notes should be switched, as it always happens after the delay ends. I used a PSC value of 3999 to set the clock to 1 kHz. This is still utilizing $CK_{CNT} = f_{CK_PSC} / ( + 1), so \\(CK_{CNT}\\) = 4 MHz / (3999 + 1) = 1 kHz. ARR correlates to the timer delay in the following way: \\(T_{delay} = (\\text{ARR} + 1) / CK_{CNT}\\). Thus, we can solve for ARR based on our desired frequency: \\(\\text{ARR} = (100 * T_{delay}) - 1\\). Thus, I can now calculate my maximum and minimum durations:\n\n\n\nMaximum and Minimum supported delays\n\n\nTo set the delays, I create a setDelay function, which can be seen in my TIM6.c code below:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/19/25\n\n// Code to utilize TIM6 for delays\n\n#include \"../lib/STM32L432KC_TIM6.h\"\n#include \"../lib/STM32L432KC_RCC.h\"\n\nvoid configureTIM6() {\n\n    // Set clock to 4 MHz\n    RCC-&gt;APB1ENR1 |= (1 &lt;&lt; 4);\n    \n    // Set clock to 1 kHz\n    TIM6-&gt;TIM6_PSC = 3999;\n\n    // Set the auto-reload preload enable in TIM16_CR1\n    TIM6-&gt;TIM6_CR1 |= (1 &lt;&lt; 7);\n\n    // Set update generation bit in TIM16_EGR\n    TIM6-&gt;TIM6_EGR |= (1 &lt;&lt; 0);\n}\n\nvoid setDelay(int ms) {\n    \n    // Set auto-reload registers in TIM6_ARR\n    TIM6-&gt;TIM6_ARR = ms - 1;\n\n    // Set update generation bit in TIM16_EGR\n    TIM6-&gt;TIM6_EGR |= (1 &lt;&lt; 0);\n\n    // Clear UIF in TIM6_SR\n    TIM6-&gt;TIM6_SR &= ~(1 &lt;&lt; 0);\n\n    // Reset Count in TIM6_CNT\n    TIM6-&gt;TIM6_CNT = 0;\n\n    // Set timer counter enable in TIM16_CR1\n    TIM6-&gt;TIM6_CR1 |= (1 &lt;&lt; 0);\n\n    while(!(TIM6-&gt;TIM6_SR & 1)){\n\n    }\n\n    // Clear UIF in TIM6_SR\n    TIM6-&gt;TIM6_SR &= ~(1 &lt;&lt; 0);\n}\n\n\nMain Code File\nTo tie everything together and actually run my code on the MCU, I had a main.c file. I first configured my two timers, and then used for loops to play each of the songs, Fur Elise and Twinkle Twinkle Little Star. I utilized my setPWM function to change frequencies after setDelay finished. My code is as shows below:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/19/25\n\n// Main lab code to program onto MCU\n\n#include \"../lib/STM32L432KC_FLASH.h\"\n#include \"../lib/STM32L432KC_GPIO.h\"\n#include \"../lib/STM32L432KC_RCC.h\"\n#include \"../lib/STM32L432KC_TIM16.h\"\n#include \"../lib/STM32L432KC_TIM6.h\"\n\n// Pitch in Hz, duration in ms\nconst int notes[][2] = {\n{659,125},{623,125},{659,125},{623,125},{659,125},{494,125},{587,125},{523,125},{440,250},{0,125},{262,125},{330,125},{440,125},{494,250},\n{0,125},{330,125},{416,125},{494,125},{523,250},{0,125},{330,125},{659,125},{623,125},{659,125},{623,125},{659,125},{494,125},{587,125},\n{523,125},{440,250},{0,125},{262,125},{330,125},{440,125},{494,250},{0,125},{330,125},{523,125},{494,125},{440,250},{0,125},{494,125},\n{523,125},{587,125},{659,375},{392,125},{699,125},{659,125},{587,375},{349,125},{659,125},{587,125},{523,375},{330,125},{587,125},{523,125},\n{494,250},{0,125},{330,125},{659,125},{0,250},{659,125},{1319,125},{0,250},{623,125},{659,125},{0,250},{623,125},{659,125},{623,125},{659,125},\n{623,125},{659,125},{494,125},{587,125},{523,125},{440,250},{0,125},{262,125},{330,125},{440,125},{494,250},{0,125},{330,125},{416,125},\n{494,125},{523,250},{0,125},{330,125},{659,125},{623,125},{659,125},{623,125},{659,125},{494,125},{587,125},{523,125},{440,250},{0,125},\n{262,125},{330,125},{440,125},{494,250},{0,125},{330,125},{523,125},{494,125},{440,500},{0,0}\n};\n\n\n// Twinkle Twinkle Little Star\n// Pitch in Hz, duration in ms\nconst int ttls_notes[][2] = {\n    {262, 125}, {0, 50}, {262, 125}, {0, 50}, {392, 125}, {0, 50}, {392, 125}, {0, 50}, {440, 125}, {0, 50}, {440, 125}, {0, 50}, {392, 250}, {0, 50}, // C C G G A A G\n    {349, 125}, {0, 50}, {349, 125}, {0, 50}, {330, 125}, {0, 50}, {330, 125}, {0, 50}, {294, 125}, {0, 50}, {294, 125}, {0, 50}, {262, 250}, {0, 50}, // F F E E D D C\n    {392, 125}, {0, 50}, {392, 125}, {0, 50}, {349, 125}, {0, 50}, {349, 125}, {0, 50}, {330, 125}, {0, 50}, {330, 125}, {0, 50}, {294, 250}, {0, 50}, // G G F F E E D\n    {392, 125}, {0, 50}, {392, 125}, {0, 50}, {349, 125}, {0, 50}, {349, 125}, {0, 50}, {330, 125}, {0, 50}, {330, 125}, {0, 50}, {294, 250}, {0, 50}, // G G F F E E D\n    {262, 125}, {0, 50}, {262, 125}, {0, 50}, {392, 125}, {0, 50}, {392, 125}, {0, 50}, {440, 125}, {0, 50}, {440, 125}, {0, 50}, {392, 250}, {0, 50}, // C C G G A A G\n    {349, 125}, {0, 50}, {349, 125}, {0, 50}, {330, 125}, {0, 50}, {330, 125}, {0, 50}, {294, 125}, {0, 50}, {294, 125}, {0, 50}, {262, 500},           // F F E E D D C\n    {0, 0}\n};\n\n\nint main(void) {\n    configureTIM16(); // PWM\n    configureTIM6(); // Delay\n\n    pinMode(6, GPIO_ALT);\n    GPIO-&gt;AFRL &= ~(0xF &lt;&lt; 24);    // Clear bits [27:24] for pin 6\n    GPIO-&gt;AFRL |= (14 &lt;&lt; 24);      // Set to AF14 for TIM16_CH1\n    \n    for (int i = 0; i &lt; sizeof(notes)/sizeof(notes[0]); i++){\n        setPWM(notes[i][0], 50);\n        setDelay(notes[i][1]);\n    }\n\n    for (int i = 0; i &lt; sizeof(ttls_notes)/sizeof(ttls_notes[0]); i++){\n        setPWM(ttls_notes[i][0], 50);\n        setDelay(ttls_notes[i][1]);\n    }\n\n    \n}\n\n\n\nHardware\n\nDesign and Schematic\nI can now build my hardware and program my MCU. I only have one pin output for my speaker and I am using PA6 since it utilizes TIM16 in AF14.\n\n\n\nAlternate functions AF8 to AF15\n\n\nBelow, is my schematic:\n\n\n\nLab 4 Schematic\n\n\nLM386 Low Voltage Audio Power Amplifier I used an LM386 Low Voltage Audio Power Amplifier to drive a stronger audio signal from my PA6 pin output to my 8 Ohm Speaker by increasing the current. Using the default setup with no capacitor between pins 1 & 8, the gain would be 20. AC coupling was not needed from amplifier to speaker to produce acceptable square waves. This amplifier was hooked up to a 5 V supply from the MCU.\nPotentiometer I chose to use a 2k Ohm Potentiometer as it would lower the volume of the speaker and be able to control the output volume but not make the volume output too low as some of the speakers that I used were not very loud/powerful.\n\n\nResults\nAfter creating my Segger project and uploading the code to my MCU, I was successfully able to play Fur Elise and Twinkle Twinkle Little Star. To make sure that my frequency outputs were accurate to within 1% error, I used an oscilloscope to measure the actual output frequencies for 220, 300, 400, 500, 600, 700, 800, 900, and 1000 Hz. Below are the oscilloscope traces and the percent error, which is within 1%:\n\n220 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 220 Hz, I got 219 Hz, which corresponds to a 0.45 % error. Theoretically, I should be getting ARR to be 1000000/220 - 1 = 4544. Thus, the output frequency should be 1000000/4545 = 220.02 Hz, which is 0.01% error.\n\n\n\n220 Hz Oscilloscope Trace\n\n\n\n\n300 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 300 Hz, I got 299 Hz, which corresponds to a 0.33 % error. Theoretically, I should be getting ARR to be 1000000/300 - 1 = 3332. Thus, the output frequency should be 1000000/3333 = 300.03 Hz, which is 0.01% error.\n\n\n\n300 Hz Oscilloscope Trace\n\n\n\n\n400 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 400 Hz, I got 397 Hz, which corresponds to a 0.75 % error. Theoretically, I should be getting ARR to be 1000000/400 - 1 = 2499. Thus, the output frequency should be 1000000/2500 = 400.00 Hz, which is 0.00% error.\n\n\n\n400 Hz Oscilloscope Trace\n\n\n\n\n500 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 500 Hz, I got 500 Hz, which corresponds to a 0 % error. Theoretically, I should be getting ARR to be 1000000/500 - 1 = 1999. Thus, the output frequency should be 1000000/2000 = 500.00 Hz, which is 0.00% error.\n\n\n\n500 Hz Oscilloscope Trace\n\n\n\n\n600 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 600 Hz, I got 595 Hz, which corresponds to a 0.83 % error. Theoretically, I should be getting ARR to be 1000000/600 - 1 = 1665. Thus, the output frequency should be 1000000/1666 = 600.24 Hz, which is 0.04% error.\n\n\n\n600 Hz Oscilloscope Trace\n\n\n\n\n700 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 700 Hz, I got 699 Hz, which corresponds to a 0.14 % error. Theoretically, I should be getting ARR to be 1000000/700 - 1 = 1427. Thus, the output frequency should be 1000000/1428 = 700.28 Hz, which is 0.04% error.\n\n\n\n700 Hz Oscilloscope Trace\n\n\n\n\n800 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 800 Hz, I got 806 Hz, which corresponds to a 0.75 % error. Theoretically, I should be getting ARR to be 1000000/800 - 1 = 1249. Thus, the output frequency should be 1000000/1250 = 800.00 Hz, which is 0.00% error.\n\n\n\n800 Hz Oscilloscope Trace\n\n\n\n\n900 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 900 Hz, I got 893 Hz, which corresponds to a 0.78 % error. Theoretically, I should be getting ARR to be 1000000/900 - 1 = 1110. Thus, the output frequency should be 1000000/1111 = 900.09 Hz, which is 0.01% error.\n\n\n\n900 Hz Oscilloscope Trace\n\n\n\n\n1000 Hz Measured Frequency\nUsing an oscilloscope to measure the actual output frequency of 1000 Hz, I got 1000 Hz, which corresponds to a 0 % error. Theoretically, I should be getting ARR to be 1000000/1000 - 1 = 999. Thus, the output frequency should be 1000000/1000 = 1000.00 Hz, which is 0.00% error.\n\n\n\n1000 Hz Oscilloscope Trace\n\n\n\n\nDemo Video\nHere is a video demoing my project working successfully:\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype",
    "href": "labs/lab4/lab4.html#ai-prototype",
    "title": "Lab 4: Digital Audio",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt\nTo test how AI would do for this lab, I entered the following prompt to ChatGPT:\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\nAI Response\nAs a result, it returned the following response:\n1. Which timers are available on STM32L432KC?\n\nThe L432KC has several general-purpose and advanced timers:\n\nTIM1 (advanced-control, 16-bit, with complementary PWM outputs, dead-time insertion, etc.)\n\nTIM2 (general-purpose, 32-bit)\n\nTIM15, TIM16, TIM17 (general-purpose, 16-bit, simpler)\n\nFor generating output frequencies between 220 Hz and 1 kHz on a GPIO pin, you want:\n\nSomething that easily routes to GPIO with an alternate function (AF).\n\nConfigurable prescaler and auto-reload for flexible frequency setting.\n\n✅ Best choice: TIM2\n\nIt’s 32-bit, so you don’t risk overflow for long periods (low frequencies).\n\nEasy to connect to GPIO pins via PWM output channels (CH1–CH4).\n\nGeneral-purpose, so no advanced motor-control baggage like TIM1.\n\n2. Relevant formulae\n\nThe timer frequency output depends on:\n\n𝑓_𝑡𝑖𝑚𝑒𝑟 = 𝑓_𝐶𝐿𝐾/(𝑃𝑆𝐶+1)×(𝐴𝑅𝑅+1)\n\nWhere:\n\n𝑓_𝐶𝐿𝐾 = timer input clock (often APB1/2 timer clock, e.g. 80 MHz on L432 with max system clock)\n\nPSC = Prescaler (16-bit register TIMx_PSC)\n\nARR = Auto-reload register (TIMx_ARR)\n\nThe timer counts from 0 → ARR, then resets.\n\nPWM toggle occurs when CNT = CCRx (TIMx_CCRx).\n\nFor a square wave, you want a 50% duty cycle:\n\n𝐶𝐶𝑅 = (𝐴𝑅𝑅 + 1)/2\n\nSo frequency generation steps:\n\nPick PSC to scale down from 80 MHz to a manageable range.\n\nCompute ARR for your desired output frequency.\n\n3. Example calculations\n\nSay \nf_CLK =80 MHz.\n\nTarget: 220 Hz\nChoose PSC = 799 → prescaler divides clock by 800.\n\nf_timer = 80000000 / 800 =100000Hz\n\nNow solve for ARR:\n\nARR = 100000 / 220 − 1 ≈ 454\n\nTarget: 1000 Hz\nSame PSC = 799 → timer base = 100 kHz.\n\nARR = 100000 / 1000 − 1 = 99\n\nSo with PSC fixed, you can just vary ARR for any 220–1000 Hz output.\n\n4. Registers to configure\n\nFor PWM or toggle mode on a GPIO pin:\n\nEnable timer clock (RCC_APB1ENR1 for TIM2).\n\nConfigure GPIO pin in AF mode (e.g., PA0 → TIM2_CH1, AF1).\n\nSet PSC and ARR (TIMx_PSC, TIMx_ARR).\n\nSet CCRx for duty cycle (TIMx_CCR1). For 50% duty cycle: CCR = ARR/2.\n\nConfigure channel mode in TIMx_CCMR1 (set to PWM mode 1 or 2).\n\nEnable output in TIMx_CCER.\n\nEnable counter (TIMx_CR1.CEN).\n\nOptional: enable preload registers (TIMx_CCMR1.OCxPE, TIMx_CR1.ARPE).\n\n5. Summary\n\nBest timer: TIM2 (32-bit, flexible, easy GPIO mapping).\n\nFormula:\n\nf = f_CLK / ((PSC+1)(ARR+1))\n\n\nRegisters: RCC (enable timer), GPIOx_MODER + AFR (alternate function), TIMx_PSC, TIMx_ARR, TIMx_CCRx, TIMx_CCMR1/2, TIMx_CCER, TIMx_CR1.\n\nDo you want me to write you a minimal STM32CubeIDE C setup code snippet that outputs, say, 440 Hz on PA0 using TIM2?\n\n\n\nReflection\nAI worked pretty well here as it suggested coorrrect steps on how to use TIM2 to set this up. However, for this lab, TIM2 seems unnecessary as I do not need it to be 32 bits, so TIM16 would be my personal choice. I am sure that if I told ChatGPT to use TIM16, it would also give me accurate steps on how to set up TIM16. The calculations that ChatGPT provided for frequency using PSC and ARR all are accurate, and I used the same calculations when doing the lab myself too. Even without attachiing the reference manual, it seems very accurate, but uploading it makes it a lot more accurate and would definitely help with time saving when looking for the right sections or not understanding how to interpret or use certain parts of the reference manual. ChatGPT can be a great time saving tool for the final project to determine what registers I need to use in my MCU and how to set it up, guiding me to the right spots on the reference manual for reference."
  },
  {
    "objectID": "labs/lab4/lab4.html#hours-spent",
    "href": "labs/lab4/lab4.html#hours-spent",
    "title": "Lab 4: Digital Audio",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 18 hours on this lab."
  },
  {
    "objectID": "finalProject/proposal/proposal.html",
    "href": "finalProject/proposal/proposal.html",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "",
    "text": "The goal of the project is to demonstrate serial data transfer through a mechanical actuation mechanism rather than traditional electrical signaling. Mechanical motion, driven by solenoids, relays, and limit switches, replaces voltage as the medium for communication across nine parallel channels, with one serving as the CLK for synchronization and eight for data bits, transmitting one byte per cycle in simplex mode. Each relay energizes a solenoid when its input is HIGH, pressing a limit switch on the receiver side to register a HIGH signal. For secure communication, the sender encrypts messages using AES-128, and the receiver decrypts the transmitted bytes to reconstruct the plaintext. Communication between sender and receiver is coordinated through a web app: the user types or uploads a message, where the ESP8266/ESP32 sends/receives a request to/from the MCU–FPGA system for encryption, transmission, decryption, and final display of the recovered message on the receiver’s web page."
  },
  {
    "objectID": "finalProject/proposal/proposal.html#introduction-and-project-overview",
    "href": "finalProject/proposal/proposal.html#introduction-and-project-overview",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "",
    "text": "The goal of the project is to demonstrate serial data transfer through a mechanical actuation mechanism rather than traditional electrical signaling. Mechanical motion, driven by solenoids, relays, and limit switches, replaces voltage as the medium for communication across nine parallel channels, with one serving as the CLK for synchronization and eight for data bits, transmitting one byte per cycle in simplex mode. Each relay energizes a solenoid when its input is HIGH, pressing a limit switch on the receiver side to register a HIGH signal. For secure communication, the sender encrypts messages using AES-128, and the receiver decrypts the transmitted bytes to reconstruct the plaintext. Communication between sender and receiver is coordinated through a web app: the user types or uploads a message, where the ESP8266/ESP32 sends/receives a request to/from the MCU–FPGA system for encryption, transmission, decryption, and final display of the recovered message on the receiver’s web page."
  },
  {
    "objectID": "finalProject/proposal/proposal.html#fpga-use",
    "href": "finalProject/proposal/proposal.html#fpga-use",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "FPGA Use",
    "text": "FPGA Use\nThe project uses two FPGAs, one on each side of the communication system. Each FPGA handles AES-128 encryption and decryption while interfacing directly with the mechanical bus. The sender FPGA receives plaintext and encryption key from the MCU, encrypts it, and performs bit-banging to maintain synchronization and ensure that a complete byte is transmitted every cycle. The receiver FPGA reads each incoming byte, decrypts it, and sends the plaintext to the MCU for display. It also manages switch input synchronization through debouncing to ensure clean and reliable signal detection. The new FPGA function is highlighted below:\n\nUsing SPRAM to store encrypted ciphertext, and then pulling from the SPRAM 8 bits at a time to transfer via hardware actuation.\n\nThe FPGAs communicate with the MCUs through SPI and interface with the mechanical bus using a custom serial bit driver that handles all data transmission and input reception. The transfer rate of the bits will be set depending on how we synchonize the receiving end. Bit transfer is handled by the clock, and we can change the clock speed to achieve synchronization, and this will in turn affect how fast we can send bits across.\n\nFPGA Resource Usage\nThe FPGAs in this setup will perform AES-128 encryption and decryption, both of which rely heavily on combinational logic, resulting in high LUT usage. Most of the resources are consumed by the iterative round operations, key expansion, and storing S-box substitution tables, with additional LUTs used by the FSMs that will control the actuators and debounce switch inputs. The UPduino has built-in macros for SPI, but serial communication can also use some resources. From research on the implementation of these functions, we estimated a total of ~3500 LUTs. Since each UPDuino (iCE40UP5K) provides 5,280 logic cells, this remains within a safe utilization range. For on-board storage, only about 5 kB of the available 128 kB memory is required for S-box tables and related data. The tasks stated above are split between 2 FPGAs, therefore, we stay even further from the resource limits of the boards."
  },
  {
    "objectID": "finalProject/proposal/proposal.html#mcu-use",
    "href": "finalProject/proposal/proposal.html#mcu-use",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "MCU Use",
    "text": "MCU Use\nThe project uses two MCUs, one for each side of the system. They serve as the main interface for web communication and text encoding, converting messages into byte data that the FPGA can process. MCUs are ideal for this role due to their large on-board memory, which allows them to handle larger text data. Each MCU also participates in the encryption and decryption process, managing the exchange of keys and ciphertext/plaintext with the FPGAs. Additionally, the MCUs will control all system indicators and feedback mechanisms that help monitor the efficiency of the system. The new MCU function is shown below:\n\nUsing the TRNG to randomly generate keys for encryption. We will send these random keys to the receiver via SPI so that it can decrypt the message correctly."
  },
  {
    "objectID": "finalProject/proposal/proposal.html#non-trivial-hardware",
    "href": "finalProject/proposal/proposal.html#non-trivial-hardware",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Non Trivial Hardware",
    "text": "Non Trivial Hardware\nThis project will implement the use of a LCD Display, which will track the current progress of the transaction and display to the user. When the MCU first gets the message from the user, it will send via SPI the total message length and key to the receiver FPGA. The receiver FPGA will send the total message length to the receiver MCU. So as data transfer is occurring via hardware actuation, the MCU can calculate what percentage of data has been transferred and display that on the LCD Display via I2C."
  },
  {
    "objectID": "finalProject/proposal/proposal.html#bill-of-materials",
    "href": "finalProject/proposal/proposal.html#bill-of-materials",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\nBOM for Final Project\n\n\nPart Name\nPart Number\nQuantity\nVendor\nPrice\nLink\n\n\n\n\n12V Relay Module\nSRD-12VDC-SL-C\n10\nAEDIKO\n13.20\nLink\n\n\n12V Solenoid\nZ24G50031OJX\n9\nTEHAUX\n28.26\nLink\n\n\nRoller Lever Arm Micro Limit Switch\nKW12-3\n10\nHiLetgo\n6.60\nLink\n\n\nLCD Display with I2C Adapter\nLCD2004\n10\nSunFounder\n14.26\nLink\n\n\nFPGA\nUpduino v3.1\n2\nUpduino\nStockroom\nN/A\n\n\nMCU\nSTM32L432KC\n2\nSTM\nStockroom\nN/A\n\n\nMetal Rods\nN/A\n9\nN/A\nStockroom\nN/A\n\n\nESP8266\nESP-WROOM-02\n2\nEdwin Robotics\nStockroom\nN/A\n\n\nTotal\n\n\n\n$62.32"
  },
  {
    "objectID": "finalProject/proposal/proposal.html#project-performance-specs",
    "href": "finalProject/proposal/proposal.html#project-performance-specs",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Project Performance Specs",
    "text": "Project Performance Specs\nWe expect the toughest stage to be the mechanical bus. Synchronizing all actuators and making sure that the receiver samples at the correct time will be the biggest challenge. Since the clock is also mechanical, the whole system is susceptible to any faults from that channel. Below are the main performance specs and secondary specs to check-off to verify the process and completeness of the project:\n\nMain Performance Specs:\n\nSend 16 ASCII characters\nSend multiple blocks of messages in 128 bit blocks\nHardware actuation system functions correctly\nWebsite UI correctly takes in user input and correctly displays output message for receiver\nStatus and progress LCD respond as expected\nTRNG generates random key\nRandom key is transmited to receiver over SPI backhaul\nSPRAM correctly stores multiple 128 bit ciphertext blocks\nFPGA pulls data from SPRAM 8 bits at a time to be sent over mechanical actuation system\nText messages are correctly sent/received between the ESP8266 to the MCU\nMCU correctly encodes & decodes the received word in ASCII\nMCU-FPGA encryption/decryption modules communicate and perform as expected\n9 mechanical channels properly synchronized between the two sides.\nSystem stops immediately if received data is different from sent data.\nAll 8 data buses are read synchronously\nAble to receive & display at least 3 letters in a second i.e minimum 24bps transfer speed\n\nProject Midpoint Demo Specs: At Minimum, the following must be completed:\n\nHardware actuation system functions as expected\nESP8266 Website UI functions and can take in user messages and display output messages\nLCD Display displays text\nRTL & Code has made progress"
  },
  {
    "objectID": "finalProject/proposal/proposal.html#project-timeline-task-allocation",
    "href": "finalProject/proposal/proposal.html#project-timeline-task-allocation",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Project Timeline & Task Allocation",
    "text": "Project Timeline & Task Allocation\n\nBy 10/26/2025: Have the proposal and project approved and verified to begin working (Both).\nWeek of 10/27/2025: Submit purchase order. Develop and test MCU-FPGA encryption module (Josaphat) and MCU driver for ASCII encoding/decoding and web requests (Chistian).\nWeek of 11/03/2025: Machine and cutdown metal rods. Start assembling and testing the electronics and mechanical system. Troubleshoot annd resolve any issues errors (Both).\nWeek of 11/10/2025: Develop and test MCU-FPGA decryption module (Josaphat) and MCU code for system monitoring and fault detection (Christian).\nWeek of 11/17/2025: Preliminary testing of the full system. Connecting all parts and running all systems to check performance and troubleshoot errors (Both).\nWeek of 11/24/2025: Begin preliminary project report. Debug if any errors are still ongoing. If complete, look at implementing some strech goals or aesthetic modificatons. (Both)\nWeek of 12/01/2025: Finalize report. Perfom final system shakedown to validate all performance specs and prepare checkoff sheet. PROJECT DEMO!!! (Both)"
  },
  {
    "objectID": "finalProject/proposal/proposal.html#appendix",
    "href": "finalProject/proposal/proposal.html#appendix",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Appendix",
    "text": "Appendix\nThe appendix contains images and diagrams highlighing the full setup and other considerations to ensure the project goes as planned:\nAll the relevant elements defined in the description above and will be connected together following the communication protocols and setup in Figure 1 below:\n\n\n\n\n\n\nFigure 1: Main Block Diagram.\n\n\n\nBelow is also a flowchart of how messages go from the user to receiver through our project in Figure 2:\n\n\n\n\n\n\nFigure 2: Message Flowchart\n\n\n\nThe actuation block requires different modules and setup necessary for it to work as expected. The relay module specifications show the mentioned NO and NC connection modes. Figure 3 below shows the signals as well as voltage and circuit configurations:\n\n\n\n\n\n\nFigure 3: Hardware Actuation Block Diagram\n\n\n\n\n\n\n\n\n\nFigure 4: Hardware Actuation 3D Visualization\n\n\n\nThe team has a fall-back plan in case new errors and challenges come up along the way to ensure that at least the main idea of transfering encrypted data mechanically still stands.\n\n\n\n\n\n\nFigure 5: Fallback Plan"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "HMC E155 Course Website:  Link"
  }
]