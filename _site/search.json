[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "HMC E155 Course Website:  Link"
  },
  {
    "objectID": "labs/overview.html",
    "href": "labs/overview.html",
    "title": "Overview",
    "section": "",
    "text": "Lab 1: E155 Website Description\nLab 1: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-1-board-assembly-and-testing",
    "href": "labs/overview.html#lab-1-board-assembly-and-testing",
    "title": "Overview",
    "section": "",
    "text": "Lab 1: E155 Website Description\nLab 1: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/overview.html#lab-2-multiplexed-7-segment-display",
    "title": "Overview",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nLab 2: E155 Website Description\nLab 2: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-3-keypad-scanner",
    "href": "labs/overview.html#lab-3-keypad-scanner",
    "title": "Overview",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nLab 3: E155 Website Description\nLab 3: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-4-digital-audio",
    "href": "labs/overview.html#lab-4-digital-audio",
    "title": "Overview",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nLab 4: E155 Website Description\nLab 4: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-5-interrupts",
    "href": "labs/overview.html#lab-5-interrupts",
    "title": "Overview",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nLab 5: E155 Website Description\nLab 5: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/overview.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Overview",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\nLab 6: E155 Website Description\nLab 6: Writeup"
  },
  {
    "objectID": "labs/overview.html#lab-7-the-advanced-encryption-standard-aes",
    "href": "labs/overview.html#lab-7-the-advanced-encryption-standard-aes",
    "title": "Overview",
    "section": "Lab 7: The Advanced Encryption Standard (AES)",
    "text": "Lab 7: The Advanced Encryption Standard (AES)\nLab 7: E155 Website Description\nLab 7: Writeup"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "",
    "text": "The goal of this lab is to implement a time-multiplexer to drive two seven segment displays with a single set of FPGA I/O pins, using a transistor circuit to drive large currents from our FPGA to our dual seven-segment display, to output the hexadecimal numbers of two dip switches. There will also be five LEDs on the breadboard, which will display the sum of the two input values."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "",
    "text": "The goal of this lab is to implement a time-multiplexer to drive two seven segment displays with a single set of FPGA I/O pins, using a transistor circuit to drive large currents from our FPGA to our dual seven-segment display, to output the hexadecimal numbers of two dip switches. There will also be five LEDs on the breadboard, which will display the sum of the two input values."
  },
  {
    "objectID": "labs/lab2/lab2.html#fpga-design",
    "href": "labs/lab2/lab2.html#fpga-design",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nObjective\nThe objective of this lab is to use System Verilog to code a time-multiplexer to run both halves of my dual seven-segment display by switching between turning on the common anode of each display so that the naked eye cannot see the flickering of the two displays. To be able to supply the large current needed by the display, 2N3906 PNP transistors will be used. We will also use an adder to sum the two hexadecimal inputs from our dip switches and display that on five LEDs.\n\n\nDesign\n\nBlock Diagram\nMy approach to this lab consists on five different modules. It was designed to have many modules to make testing the functionality of each function of this lab easily. An overarching top level module called lab2_cw, which will be programmed to the board, and four submodules adder, sevenSegmentDisplay, timeMultiplexer, and sevenSegMux. The adder submodule will give the 5 bit sum of two four bit inputs, so that we can show the sum of our two inputs on five LEDS. The sevenSegmentDisplay submodule is the same one that was used in Lab 1, which will control the outputs on the 7-segment display, displaying the hexadecimal value provided by the dip switches, s1[3:0] and s2[3:0]. The timeMultiplexer submodule is responsible for controlling which common anode gets turned on in the dual 7-segment display. It was designed to switch at 500 Hz, which should be high enough to not be noticeable to the human eye. It will also output a signal to guide which input should be used by the sevenSegmentDisplay module, which is controlled by sevenSegMux. The sevenSegMux module is a mux that controls which four bit input will be fed into sevenSegmentDisplay based on the enable, signal, which is given by timeMultiplexer. The top level lab2_cw calls upon all these submodules as well as the HSOSC submodule, which takes advantage of the onboard 48 MHz clock on the FPGA. Below is the block diagram I used to create this project:\n\n\n\nLab 2 Block Diagram\n\n\n\n\nAdder Design\nThe adder submodule was a very simple design. It simply consisted of combinational logic that produced a 5 bit output, sum, from two four bit inputs, a and b.\nBelow is the code block that was used for this submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module is a 4-bit adder that takes in two 4-bit inputs a and b, and outputs a 5-bit sum.\nmodule adder (\n    input logic [3:0] a, b,\n    output logic [4:0] sum);\n\n    always_comb begin\n        sum = a + b;\n    end\nendmodule\n\n\nSeven Segment Display Design\nThis submodule is coopied from Lab 1 and uses the exact same code. Designing the sevenSegmentDisplay submodule was fairly simple. It involved using a case statement to write out the outputs, seg[6:0] of the 7-segment display for all 16 possible inputs of s[3:0]. While writing the code, it is worth noting that turning on each segment of the 7-segment display was with a 0 output as the cathode is connected to each output pin.\nBelow is a labeled image of each segment of the 7-segment display and the code for this submodule, where s[0] is segment A and s[6] is segment G of the 7-segment display:\n\n\n\n7-segment display segment mapping\n\n\n// sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0].\nmodule lab1_sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\n\n\nTime Multiplexer Design\nThe main purpose of the timeMultiplexer submodule is to switch between each common anode on our dual 7-segment display, so that we only need one sevenSegmentDisplay submodule to control both digits. Thus, we are turning on one side of the dual 7-segment display on at a time, but if we do it fast enough, the human eye cannot notice each digit turning on and off. To switch between the two common anodes fast enough, I chose to switch between each display at 500 Hz. This is done by using the FPGA’s onboard 48 MHz clock, and using a counter. 500 Hz is equivalent to 0.002 seconds per cycle, and assuming a 50% duty cycle, we must switch from one common anode to the other every 0.001 seconds. For a 48 MHz clock, this would equate to 48000 ticks. Thus, we can use a counter to turn each side of the dual 7-segment display on or off, every 48000 ticks. At the same time, we can also output, signal, to tell the sevenSegMux submodule, which input to display on the corresponding side of the dual 7-segment display\nBelow is the code for the timeMultiplexer submodule:\n//  timeMultiplexer.sv\n//  Christian Wu\n//  chrwu@g.hmc.edu\n//  09/06/25\n\n// This module takes in two four bit inputs, s1 and s2, and switches between them to drive a dual seven\n// segment display, to utilize only one sevenSegmentDisplay module. The switching is done at a rate fast enough\n// such that the human eye cannot detect the switching, and it appears that both displays are on at the same time.\n\nmodule timeMultiplexer (\n    input clk,\n    output logic an1, an2,\n    output logic signal);\n\n    logic [24:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        counter &lt;= counter + 1;\n        if (counter == 48000) begin\n            counter &lt;= 0;\n            signal &lt;= ~signal; \n            if (~signal) begin\n                an1 &lt;= 1; // turn off an1\n                an2 &lt;= 0; // turn on an2\n            end else begin\n                an1 &lt;= 0; // turn on an1\n                an2 &lt;= 1; // turn off an2\n            end\n\n    end\n    end\nendmodule\n\n\nSeven Segment Mux Design\nThe design for the sevenSegMux submodule is quite simple. This submodule depicts a simple mux with an enable on it. This submodule is used to output the correct 4 bit input into the sevenSegmentDisplay submodule. When the enable is on, we set the ouput to be s2, and when it is off, we set the output to be s1.\nBelow is the code for the sevenSegMux submodule:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module takes in two 4-bit inputs, s1 and s2, and an enable, and outputs one \n// of the inputs to a 4-bit output based on the enable signal for the seven-segment display\n\nmodule sevenSegMux (\n    input logic [3:0] s1, s2,\n    input logic enable,\n    output logic [3:0] out);\n\n    always_comb begin\n        if (enable) begin\n            out = s2;\n        end else begin\n            out = s1;\n        end\n    end\nendmodule\n\n\nTop Level Module\nGiven that this lab project was split into one top level module and four submodules, the top level module is quite simple. It is a module that calls upon the four submodules, adder, sevenSegmentDisplay, timeMultiplexer, and sevenSegMux. It also calls upon the HSOSC module to take advantage of the onboard 48 MHz clock on the FPGA. This top level module, lab2_cw, will then be programmed onto the FPGA.\nBelow is the code for the top level module, lab2_cw:\n// lab2_cw.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module is the top level module for lab 2. It instantiates the timeMultiplexer module to drive the\n// seven-segment display, and connects the dip switches to the inputs of the timeMultiplexer module. It also displays\n// the sum of the two 4-bit inputs on five LEDs.\n\nmodule lab2_cw (\n    input logic [3:0] s1, s2, // dip switches\n    output logic [6:0] seg, // seven-segment display\n    output logic an1, an2, // anodes for the two displays\n    output logic [4:0] sum); // 5 LEDs to display sum\n\n    \n    logic [3:0] sevenSegmentSignal;\n    logic signal; // select signal to choose between s1 and s2\n    logic clk;\n    \n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\n    timeMultiplexer tm (.clk(clk), .an1(an1), .an2(an2), .signal(signal));\n    sevenSegMux ssm (.s1(s1[3:0]), .s2(s2[3:0]), .enable(signal), .out(sevenSegmentSignal));\n    sevenSegmentDisplay ssd (.s(sevenSegmentSignal), .seg(seg));\n    adder a (.a(s1[3:0]), .b(s2[3:0]), .sum(sum[4:0]));\nendmodule\n\n\n\nTestbench Simulation and Testing\n\nTestbench Design and Results\nTo test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench for each of my five modules, testing a different functionality of this lab with east testbench. For the adder submodule, I tested all 256 possible cases using a for loop to make sure that the output sum was correct. For the sevenSegmentDisplay submodule, I tested all 16 possible 4 bit inputs and made sure that the 7 bit output was correct. For the timeMultiplexer submodule, I tested the sequential logic that occurs in this submodule to check that the submodule switches between turning on each common anode on the dual 7-segment display, and correctly outputs the right signal for the sevenSegMux to use. For the sevenSegMux submodule, I tested that the mux would output the right 4 bit value from the two 4 bit inputs, based on whether the enable was on or off. For the top level lab2_cw module, it was used to test that the HSOSC module worked, by sampling a few different test cases and making sure that the dual 7-segment display would show both of the values by switching between outputting each one.\nEach of the testbenches were done by using the stim/assert method, to ensure functionality automatically, without having to analyze the waveforms carefully to see if it worked or not.\n\nadder_testbench results:\nThis testbench tested the combinational logic of the adder submodule, testing all 256 cases. Below is the code used for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the 4-bit adder module by providing various test cases and checking the output.\n`timescale 1ns/1ps\n\nmodule adder_testbench();\n    logic [3:0] a, b;\n    logic [4:0] sum;\n    logic [4:0] expected_sum;\n    adder dut (.a(a), .b(b), .sum(sum));\n\n    integer i,j;\n    integer test_cases = 0;\n\n    initial begin\n        // Test all combinations of 4-bit inputs\n        for (i = 0; i &lt; 16; i++) begin\n            for (j = 0; j &lt; 16; j++) begin\n                a = i[3:0];\n                b = j[3:0];\n                #1; // wait for combinational logic to settle\n                test_cases++;\n                expected_sum = a + b;\n                assert (sum === expected_sum)\n                    else $error(\"ASSERTION FAILED: a=%0d, b=%0d, expected sum=%0d, got sum=%0d\", a, b, expected_sum, sum);\n            end\n        end\n\n        $display(\"All %0d test cases completed with\", test_cases);\n        $stop;\n    end\nendmodule\nBelow are the Questa simulation results:\n\n\n\nadder Waveforms\n\n\n\n\n\nadder Transcript\n\n\n\n\nsevenSegmentDisplay_testbench results:\nThis testbench tested the combinational logic of the sevenSegmentDisplay submodule, testing all 16 cases. Below is the code used for my testbench:\n// sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/06/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0]. This module is copy and pasted from lab 1\nmodule sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\nBelow are the results of the Questa simulation of this testbench:\n\n\n\nsevenSegmentDisplay Waveforms\n\n\n\n\n\nsevenSegmentDisplay Transcript\n\n\n\n\ntimeMultiplexer_testbench results:\nThis testbench tested the sequential logic of switching between turning on each common anode, and outputting the right signal for the sevenSegmentMux submodule. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the timeMultiplexer module by simulating clock cycles and checking if the an1, an2, and signal outputs\n// toggle correctly based on the internal counter.\n\n// timeMultiplexer_simple_tb.sv\n// Simple testbench focusing only on an1 and an2 switching behavior\n\n`timescale 1ns / 1ps\n\nmodule timeMultiplexer_testbench();\n    logic clk;\n    logic an1, an2;\n    logic signal;\n    \n    timeMultiplexer dut (.clk(clk), .an1(an1), .an2(an2), .signal(signal));\n    \n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; \n    end\n    \n    // Test sequence\n    initial begin\n        repeat(10) begin\n            @(posedge signal or negedge signal);\n            #1;\n        end\n        \n        $display(\"Test completed successfully.\");\n        $stop;\n    end\n    \n    // Assert statements for anode behavior\n    always @(*) begin\n        // Assert anodes are always opposite (mutually exclusive)\n        assert (an1 !== an2)\n        else $error(\"Anodes not mutually exclusive: an1=%b, an2=%b\", an1, an2);\n        \n        // Assert correct anode control based on signal\n        assert (signal ? (an1 == 1 && an2 == 0) : (an1 == 0 && an2 == 1))\n        else $error(\"Incorrect anode control: signal=%b, an1=%b, an2=%b\", signal, an1, an2);\n        \n        // Assert only one display is active at a time (one anode is 0)\n        assert ((an1 == 0) ^ (an2 == 0))\n        else $error(\"Neither or both displays active: an1=%b, an2=%b\", an1, an2);\n    end\n    \nendmodule\nI also used an oscilloscope to confirm that the switching between the two sides of the dual 7-segment display is at 500 Hz:\n\n\n\nOscilloscope trace switching displays at 500 Hz\n\n\nBelow are the Questa simulation results:\n\n\n\ntimeMultiplexer Waveforms\n\n\n\n\n\ntimeMultiplexer Transcript\n\n\n\n\nsevenSegMux_testbench results:\nThis testbench tested that the mux worked as expected, testing all 512 cases. Below is the code for my testbench:\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// This module tests the sevenSegMux module by inputing all combinations of s1, s2, and enable signals\n// and checking if the output is as expected.\n\n`timescale 1ns/1ps\n\nmodule sevenSegMux_testbench();\n    logic [3:0] s1, s2;\n    logic enable;\n    logic [3:0] out;\n    sevenSegMux dut (.s1(s1), .s2(s2), .enable(enable), .out(out));\n\n    integer i, j;\n    integer errors = 0;\n    integer test_cases = 0;\n    logic [3:0] expected_out;\n\n    initial begin\n        // Test all combinations of 4-bit inputs and enable signal\n        for (i = 0; i &lt; 16; i++) begin\n            for (j = 0; j &lt; 16; j++) begin\n                s1 = i[3:0];\n                s2 = j[3:0];\n\n                // Test with enable = 0\n                enable = 0;\n                #10; \n                test_cases++;\n                expected_out = s1;\n                assert (out === expected_out)\n                    else $error(\"ASSERTION FAILED: s1=%0d, s2=%0d, enable=0, expected out=%0d, got out=%0d\", s1, s2, expected_out, out);\n\n                // Test with enable = 1\n                enable = 1;\n                #10; \n                test_cases++;\n                expected_out = s2;\n                assert (out === expected_out)\n                    else $error(\"ASSERTION FAILED: s1=%0d, s2=%0d, enable=1, expected out=%0d, got out=%0d\", s1, s2, expected_out, out);\n            end\n        end\n\n        $display(\"All %0d test cases successfully completed.\", test_cases);\n        $stop;\n    end\n    endmodule\nBelow are the Questa simulation results:\n\n\n\nsevenSegMux Waveforms\n\n\n\n\n\nsevenSegMux Transcript\n\n\n\n\nlab2_cw_testbench results:\nThis testbench tested the HSOSC module and the overall functionality of this lab by using a few sample test cases. Below is the code for my testbench:\n// lab2_cw_testbench.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 09/08/25\n\n// Simple testbench for lab2_cw module - tests each case one at a time\n\n`timescale 1ns / 1ps\n\nmodule lab2_cw_testbench;\n    logic [3:0] s1, s2;\n    logic [6:0] seg;\n    logic [6:0] expected_seg;\n    logic an1, an2;\n    logic [4:0] sum;\n    logic [4:0] expected_sum;\n    \n    logic [6:0] seg_patterns [16] = {\n        7'b1000000, // 0\n        7'b1111001, // 1\n        7'b0100100, // 2\n        7'b0110000, // 3\n        7'b0011001, // 4\n        7'b0010010, // 5\n        7'b0000010, // 6\n        7'b1111000, // 7\n        7'b0000000, // 8\n        7'b0010000, // 9\n        7'b0001000, // A\n        7'b0000011, // b\n        7'b1000110, // C\n        7'b0100001, // d\n        7'b0000110, // E\n        7'b0001110  // F\n    };\n    \n    // Instantiate the Device Under Test (DUT)\n    lab2_cw dut (.s1(s1), .s2(s2), .seg(seg), .an1(an1), .an2(an2), .sum(sum));\n    \n    initial begin\n        // Test Case 1: 0 + 0 = 0\n        s1 = 4'h0;\n        s2 = 4'h0;\n        expected_sum = 5'd0;\n        #2000000; // Wait 2ms for display to switch (500Hz = 2ms period)\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        // Wait for display 1 to be active (an1 = 0)\n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        // Wait for display 2 to be active (an2 = 0) \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 2: 5 + 3 = 8\n        s1 = 4'h5;\n        s2 = 4'h3;\n        expected_sum = 5'd8;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 3: A + 7 = 17\n        s1 = 4'hA;\n        s2 = 4'h7;\n        expected_sum = 5'd17;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 4: F + F = 30 (maximum)\n        s1 = 4'hF;\n        s2 = 4'hF;\n        expected_sum = 5'd30;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        // Test Case 5: 8 + 8 = 16\n        s1 = 4'h8;\n        s2 = 4'h8;\n        expected_sum = 5'd16;\n        #100;\n        \n        assert (sum === expected_sum)\n        else\n            $error(\"Sum wrong: %0d + %0d = %0d, expected %0d\", s1, s2, sum, expected_sum);\n        \n        wait (an1 == 0); #10;\n        expected_seg = seg_patterns[s1];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 1 wrong pattern for s1=%h, expected=%b, got=%b\", s1, seg_patterns[s1], seg);\n        \n        wait (an2 == 0); #10;\n        expected_seg = seg_patterns[s2];\n        assert (seg === expected_seg)\n        else\n            $error(\"Display 2 wrong pattern for s2=%h, expected=%b, got=%b\", s2, seg_patterns[s2], seg);\n        \n        $display(\"All tests successfully completed.\");\n        $stop;\n    end\n    \nendmodule\nBelow are my Questa simulation results:\n\n\n\nlab2_cw Waveforms\n\n\n\n\n\nlab2_cw Transcript\n\n\nThus, all testbenches and testing for this lab was successful!\n\n\n\n\nHardware\n\nDesign and Schematic\nAfter finishing with testing, I can now build my hardware and program my FPGA. Below, is a table of all of my pin assignments, as well as my schematic:\n\nPin assignments for Lab 2 inputs and outputs\n\n\nName\nPin\n\n\n\n\ns1[0]\n37\n\n\ns1[1]\n31\n\n\ns1[2]\n35\n\n\ns1[3]\n32\n\n\ns2[0]\n44\n\n\ns2[1]\n3\n\n\ns2[2]\n45\n\n\ns2[3]\n46\n\n\nled[0]\n20\n\n\nled[1]\n12\n\n\nled[2]\n13\n\n\nled[3]\n18\n\n\nled[4]\n9\n\n\nan1\n10\n\n\nan2\n2\n\n\nseg[0]\n21\n\n\nseg[1]\n19\n\n\nseg[2]\n11\n\n\nseg[3]\n6\n\n\nseg[4]\n4\n\n\nseg[5]\n48\n\n\nseg[6]\n47\n\n\n\n\n\n\nLab 2 Schematic\n\n\nDual 7-segment Display Resistor Values\nFor the 7-segment display, resistors were added at each of the seven segment pins to prevent the display from drawing too much current. After referencing the HDSP-521A Seven Segment Display Datasheet, I found that the forward voltage for the display is 2 V. Given that we are using a 3.3 V source voltage from the FPGA, the voltage across the resistor is 1.3 V. It is safe for the 7-segment display’s pins to be around 10-20 mA, so to keep it clean, I used 100 Ohm Resistors, giving a current of 13 mA.\n2N3906 Transistor Base Resistor Value\nWe are supplying 3.3 V to our 2N3906 PNP Transistor. We know from the data sheetthat the Base Emitter Voltage is around 0.7, so we have 2.6 V that will be dropped through the resistor that connects the base to the GPIO Pin. From the iice40 Datasheet, we know from Table 4.17 that I_OL = 8 mA. Thus, we know that we want the current to be between 1 and 8 mA. I chose to use a 1 k Ohm resistor, which gives a current of 2.6 mA, giving ample wiggle room on both ends. Below is a picture that models this math:\n\n\n\nTransistor Resistor Value Math\n\n\nLED Resistor Values\nThe forward voltage of our yellow LEDs is around 2V, and we know that the current through the LEDs should be under 20 mA. Given that we are supplying 3.3 V, the remaining voltage drop across our resistor would be 1.3 V. I chose to use a 100 Ohm resistor, which gives me a current of 13 mA, keeping the LED bright, but under the 20 mA max.\n\n\nResults\nAfter finishing with the design, I was able to wire my board according to the schematic and programming my top level module, lab2_cw, onto my board. I was able to physically verify that everything worked as expected.\nBelow are a few pictures demonstrating this lab working successfully:\n\n\n\ns1 = 6; s2 = 3; sum = 9\n\n\n\n\n\ns1 = F; s2 = 8; sum = 23\n\n\n\n\n\ns1 = 0; s2 = 5; sum = 5\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt 1\nTo test how AI would do for this lab, I entered the following prompt to Claude AI:\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nAI Code\nAs a result, it returned the following code:\n// Time-multiplexed seven segment decoder for two displays\n// Common anode seven segment display driver\nmodule seven_seg_decoder_mux (\n    input  logic        clk,           // Clock input\n    input  logic        rst_n,         // Active-low reset\n    input  logic [3:0]  digit0_in,     // First 4-bit input\n    input  logic [3:0]  digit1_in,     // Second 4-bit input\n    output logic [6:0]  seg0_out,      // Seven segment output for display 0 (a-g)\n    output logic [6:0]  seg1_out,      // Seven segment output for display 1 (a-g)\n    output logic        digit0_enable, // Enable signal for display 0\n    output logic        digit1_enable  // Enable signal for display 1\n);\n\n    // Internal signals\n    logic [3:0] mux_input;     // Multiplexed input to decoder\n    logic [6:0] decoded_seg;   // Output from seven segment decoder\n    logic       mux_select;    // Multiplexer select signal\n    logic [6:0] seg0_reg;      // Registered output for display 0\n    logic [6:0] seg1_reg;      // Registered output for display 1\n    \n    // Clock divider for multiplexing (adjust counter width for desired refresh rate)\n    // With a typical 50MHz clock, this gives ~763Hz refresh per display\n    logic [15:0] clk_counter;\n    \n    // Clock divider and multiplexer select generation\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_counter &lt;= 16'd0;\n            mux_select &lt;= 1'b0;\n        end else begin\n            clk_counter &lt;= clk_counter + 1;\n            // Toggle mux_select at MSB of counter\n            mux_select &lt;= clk_counter[15];\n        end\n    end\n    \n    // Input multiplexer\n    always_comb begin\n        case (mux_select)\n            1'b0: mux_input = digit0_in;\n            1'b1: mux_input = digit1_in;\n        endcase\n    end\n    \n    // Seven segment decoder (common anode - active low outputs)\n    // Segments: a=bit6, b=bit5, c=bit4, d=bit3, e=bit2, f=bit1, g=bit0\n    always_comb begin\n        case (mux_input)\n            4'h0: decoded_seg = 7'b1000000; // 0\n            4'h1: decoded_seg = 7'b1111001; // 1\n            4'h2: decoded_seg = 7'b0100100; // 2\n            4'h3: decoded_seg = 7'b0110000; // 3\n            4'h4: decoded_seg = 7'b0011001; // 4\n            4'h5: decoded_seg = 7'b0010010; // 5\n            4'h6: decoded_seg = 7'b0000010; // 6\n            4'h7: decoded_seg = 7'b1111000; // 7\n            4'h8: decoded_seg = 7'b0000000; // 8\n            4'h9: decoded_seg = 7'b0010000; // 9\n            4'hA: decoded_seg = 7'b0001000; // A\n            4'hB: decoded_seg = 7'b0000011; // b\n            4'hC: decoded_seg = 7'b1000110; // C\n            4'hD: decoded_seg = 7'b0100001; // d\n            4'hE: decoded_seg = 7'b0000110; // E\n            4'hF: decoded_seg = 7'b0001110; // F\n        endcase\n    end\n    \n    // Output registers - capture decoded value when corresponding digit is selected\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            seg0_reg &lt;= 7'b1111111; // All segments off (common anode)\n            seg1_reg &lt;= 7'b1111111;\n        end else begin\n            if (mux_select == 1'b0) begin\n                seg0_reg &lt;= decoded_seg;\n            end else begin\n                seg1_reg &lt;= decoded_seg;\n            end\n        end\n    end\n    \n    // Output assignments\n    assign seg0_out = seg0_reg;\n    assign seg1_out = seg1_reg;\n    \n    // Generate enable signals (active low for common anode displays)\n    // Only one display is enabled at a time for time multiplexing\n    assign digit0_enable = ~mux_select;  // Active when mux_select = 0\n    assign digit1_enable = mux_select;   // Active when mux_select = 1\n\nendmodule\n\n\nTest in Radiant\nI then started a new project in Radiant and attempted to synthesize the code. Claude was able to synthesize properly and it seems like it would actually work quite well, which is really impressive. By slightly modifying this code and adapting it for the purposes of this lab, it would be able to work successfully.\n\n\n\nPrompt 2\nI then ran the second prompt by also giving my lab 1 files as a sample to base off of. I used the following prompt:\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nAI Code Result\nClaude gave me the following code.\nmodule timemux_sevenSegmentDisplay (\n    input logic [3:0] input_a,    // First 4-bit input\n    input logic [3:0] input_b,    // Second 4-bit input\n    output logic [6:0] seg,       // Common seven segment output\n    output logic enable_a,        // Enable signal for display A (active low)\n    output logic enable_b         // Enable signal for display B (active low)\n);\n\n    // Internal signals\n    logic int_osc;\n    logic mux_select = 0;\n    logic [20:0] counter = 0;\n    logic [3:0] current_input;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Clock divider for multiplexing frequency\n    always_ff @(posedge int_osc) begin\n        counter &lt;= counter + 1;\n        if (counter == 24_000) begin  // 1kHz multiplex frequency\n            mux_select &lt;= ~mux_select;\n            counter &lt;= 0;\n        end\n    end\n    \n    // Input multiplexer\n    always_comb begin\n        if (mux_select)\n            current_input = input_b;\n        else\n            current_input = input_a;\n    end\n    \n    // Generate enable signals (active low for common anode displays)\n    assign enable_a = mux_select;   // Active when mux_select is 0\n    assign enable_b = ~mux_select;  // Active when mux_select is 1\n    \n    // Instantiate the seven segment decoder\n    lab1_sevenSegmentDisplay decoder (\n        .s(current_input),\n        .seg(seg)\n    );\n\nendmodule\n\n\nRadiant Test\nI created a new project in Radiant and was able to get the code to successfully synthesize. I also assigned pins and programmed the code onto my board and it worked successfully.\n\n\n\nReflection\nI am overall very impressed with how AI performed. I was able to run the code on my board and get it to work as expected, showing the power of using AI to write quick and effective code. I learned that Claude is able to write much cleaner code than me, avoiding redundancies and having everything fit in just one module. While this is helpful here, it might not be helpful for testbenching purposes, but I think if I gave AI the right prompts, it would modify my code to make it more testbench friendly and also write the testbenches for me.\nWhat I learned here, as well as with the AI prototype of Lab 1 is that if we guide the AI to where we want it to be, it will be able to achieve what we want. If we don’t guide it at all, it will do a fairly good job, but it won’t work and it won’t be perfect. But if we guide it in the right direction, it will be able to correct those small details that are wrong and be able to run correctly on the board.\nOnce again, I am very impressed with Claude and I can see how useful it will be for the final project."
  },
  {
    "objectID": "labs/lab2/lab2.html#hours-spent",
    "href": "labs/lab2/lab2.html#hours-spent",
    "title": "Lab 2: Multiplexed Seven Segment Display",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 15 hours on this lab."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Christian Wu is a Junior at Harvey Mudd College studying Engineering, with an passion for digital electronics and hardware engineering. Christian grew up in Santiago, Chile, until he moved to the United States to attend Harvey Mudd College. His professional experience includes being a manufacturing engineering intern at Johnson & Johnson and General Motors. Christian is a Machine Shop Proctor at Harvey Mudd and enjoys playing basketball in his time off.\nThis portofolio will highlight the work done over the course of the semester in E155: Microprocessor Based Systems"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Semester Goals for E155\n\n\nThese are my initial thoughts on the course and what I hope to gain out of it\n\n\n\n\n\nAug 29, 2025\n\n\nChristian Wu\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The goal of this lab was to set up our E155 Board, soldering on all the necessary components, testing that the board functions with our FPGA and MCU, and writing code to display all hexadecimal digits on a 7-segment display and program onboard SMD LEDs"
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The goal of this lab was to set up our E155 Board, soldering on all the necessary components, testing that the board functions with our FPGA and MCU, and writing code to display all hexadecimal digits on a 7-segment display and program onboard SMD LEDs"
  },
  {
    "objectID": "labs/lab1/lab1.html#board-preparation",
    "href": "labs/lab1/lab1.html#board-preparation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Board Preparation",
    "text": "Board Preparation\nTo prepare the development board for use, all the necessary components needed to be soldered on. This includes the 5V and 3.3 V Regulators, the necessary SMT Resistors, Capacitors, and Diodes, and all the necesary THT buttons, switches, and female connector pins. I followed the Interactive Development Board BOM to keep track of all the components that I soldered.\nThe parts that gave me the most trouble while soldering were the two voltage regulators, as I could not get them to adhere to the solder and stay on the board. I was not able to melt the solder while making contact with the regulator, but after a while of trial and error and guidance from Xavier, I was able to get it to work. Other than that, the rest of the components were straight forward to solder, and the step by step suggestions on the course website aided the process.\nBelow, is a picture of my fully assembled Development Board\n\n\n\nCompleted Development Board"
  },
  {
    "objectID": "labs/lab1/lab1.html#board-testing",
    "href": "labs/lab1/lab1.html#board-testing",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Board Testing",
    "text": "Board Testing\nTo test whether the board was soldered and assembled correctly, and that the FPGA and MCU are working correctly, I first followed the Lattice Radiant iCE40 UltraPlus Project Setup Tutorial. All of the setup on Radiant went smoothly, however, I had difficulty in programming onto my FPGA. On my personal laptop, the Programmer software would crash everytime I clicked the ‘detect cable button’, and on the lab computers, I would get an FTDI error when uploading code to the FPGA. I was unable to fix this issue for around 3 days, until a new programming method was uploaded (Thank you Kavi!). Thus, I followed the openFPGALoader Programmer Tutorial and was able to successfully program my FPGA. This allowed me to finish the tutorial and successfully see the onboard LED D6 at P42 blinking.\nI continued to do further testing on the FPGA as well as the MCU, I downloaded test code from the course Lab 1 Github Repo and programmed onto my board. After running the code on both my FPGA and MCU, I saw that when I had SW7 switched on, LED D3 (PA9/P25), LED D2 (PA10/P23), and LED D7 (P38) were all blinking.\nThis means that I have successfully tested by development board, FPGA, and MCU, so I know that all my components are working as expected."
  },
  {
    "objectID": "labs/lab1/lab1.html#fpga-design",
    "href": "labs/lab1/lab1.html#fpga-design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nObjective\nNow that testing the development board, FPGA, and MCU is complete, we can start working on the lab. The objective of this lab is to take inputs, s[3:0], which are the four DIP switches on SW6, and use them to drive three onboard LEDs, led[2:0], and display the hexadecimal digit of our inputs on a 7-segment display, seg[6:0]. The inputs and outputs are described by the following table:\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\ns[3:0]\ninput\nthe four DIP switches (on the board, SW6)\n\n\nled[2:0]\noutput\n3 LEDs (you may use the on-board LEDs)\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThe output of led[2] will be programmed to blink at 2.4 Hz, while the outputs of led[1:0] can be described by the following table:\n\n\n\n\ns1\ns0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\n\n\ns3\ns2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\n\n\n\nDesign\n\nBlock Diagram\nMy approach to this lab consists on three different modules. An overarching top level module called lab1_cw, which will be programmed to the board, and two submodules lab1_ledController, and lab1_sevenSegmentDisplay. The lab1_ledController submodule will control the output of each LED, utilizing the HSOSC library to control led[2], and utilizing simple logic to control led[1:0]. The lab1_sevenSegmentDisplay submodule will control the outputs on the 7-segment display, displaying the hexadecimal value provided by the dip switches, s[3:0]. The lab1_cw module will call both the lab1_ledController submodule and the lab1_sevenSegmentDisplay submodule to run on the board. Below is the block diagram I used to create this project:\n\n\n\nLab 1 Block Diagram\n\n\n\n\nLED Design\nDesign for the lab1_ledController submodule was split into two components, designing the logic for led[1:0] based on inputs s[3:0], and making led[2] blink at 2.4 Hz.\nDesigning the logic for led[1:0] was fairly simple, based on the patterns formed from the table above. Inputs s1 and s0 control the output of led[0]. From the table, led[0] is formed by an XOR gate with inputs s1 and s0.\nInputs s3 and s2 control the output of led[1]. From the table, led[1] is formed by an AND gate, with inputs s3 and s2.\nDesigning led[2] to blink at 2.4 Hz was a bit more challenging. To run at 2.4 Hz, every full cycle of the LED should be around 0.4167 seconds per cycle. Given that the LED is on or off for only half a cycle, which is also known as a 50% duty cycle, the LED needs to change state every half cycle, or every 0.2083 seconds. The HSOSC oscillator runs at 48 MHz. So in order for us to change states at every 0.2083 seconds, the clock will need to tick 10,000,000 times. This is done using a counter, which at every 10 million clock ticks of the HSOSC oscillator, will change the state of the LED from on to off or vice versa.\nBelow is the code block that was used for this submodule:\n// lab1_ledController.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls a 3-bit LED output led[2:0], which are the SMD LEDs on the motherboard.\n\nmodule lab1_ledController (\n    input logic [3:0] s,\n    output logic [2:0] led\n);\n\n// LED Logic for led[0] and led[1]\n    xor led0_logic(led[0], s[0], s[1]);\n    and led1_logic(led[1], s[2], s[3]);\n\n    // LED Logic for led[2] to blink at 2.4 Hz\n    logic int_osc;\n    logic led_state = 0;\n    logic [24:0] counter = 0;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + 1;\n            if (counter == 10_000_000) begin // Adjust this value for 2.4 Hz\n                led_state &lt;= ~led_state;\n                counter &lt;= 0;\n            end\n        end\n    //assign led[2] to blink state    \n    assign led[2] = led_state;\n\nendmodule\n\n\nSeven Segment Display Design\nDesigning the lab1_sevenSegmentDisplay submodule was fairly simple. It involved using a case statement to write out the outputs, seg[6:0] of the 7-segment display for all 16 possible inputs of s[3:0]. While writing the code, it is worth noting that turning on each segment of the 7-segment display was with a 0 output as the cathode is connected to each output pin.\nBelow is a labeled image of each segment of the 7-segment display and the code for this submodule, where s[0] is segment A and s[6] is segment G of the 7-segment display:\n\n\n\n7-segment display segment mapping\n\n\n// lab1_sevenSegmentDisplay.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,\n// and controls the seven-segment display output seg[6:0].\nmodule lab1_sevenSegmentDisplay (\n    input logic [3:0] s,\n    output logic [6:0] seg);\n // 7-Segment Display Logic\n    always_comb begin\n        case (s)\n            4'h0: seg = 7'b1000000; // 0\n            4'h1: seg = 7'b1111001; // 1\n            4'h2: seg = 7'b0100100; // 2\n            4'h3: seg = 7'b0110000; // 3\n            4'h4: seg = 7'b0011001; // 4\n            4'h5: seg = 7'b0010010; // 5\n            4'h6: seg = 7'b0000010; // 6\n            4'h7: seg = 7'b1111000; // 7\n            4'h8: seg = 7'b0000000; // 8\n            4'h9: seg = 7'b0010000; // 9\n            4'hA: seg = 7'b0001000; // A\n            4'hB: seg = 7'b0000011; // b\n            4'hC: seg = 7'b1000110; // C\n            4'hD: seg = 7'b0100001; // d\n            4'hE: seg = 7'b0000110; // E\n            4'hF: seg = 7'b0001110; // F\n            default: seg = 7'b1111111; // Off\n        endcase\n    end\nendmodule\n\n\nTop Level Module\nGiven that this lab project was split into one top level module and two submodules, the top level module is quite simple. It is a module that calls upon the two submodules, lab1_ledController and lab1_sevenSegmentDisplay. This top level module, lab1_cw, will then be programmed onto the FPGA.\nBelow is the code for the top level module, lab1_cw:\n// lab1_cw.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This module takes in a 4-bit input 's', using the dip switches on the motherboard,  \n// and controls a 3-bit LED output led[2:0], which are the SMD LEDs on the motherboard, \n// and a 7-segment display output seg[6:0].\nmodule lab1_cw (\n    input logic [3:0] s,\n    output logic [2:0] led,\n    output logic [6:0] seg\n);\n    // call led controller module\n    lab1_ledController led_ctrl (.s(s), .led(led));\n    // call seven segment display module\n    lab1_sevenSegmentDisplay seg_ctrl (.s(s), .seg(seg));\n\nendmodule\n\n\n\nTestbench Simulation and Testing\n\nTestbench and Test Vector Design\nTo test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench of each of my three modules. For the top level module, lab1_cw, I tested that the LED and 7-segment display outputs would be correct based on the dip switch input. For the lab1_ledController submodule, I tested just the LED outputs with the dip switch input. For the lab1_sevenSegmentDisplay submodule, I tested just the 7-segment display output with the dip switch input. For both the lab1_cw module and the lab1_ledController submodule, I omitted led[2] from the testbench and test vectors as it is blinking at 2.4 Hz.\nTo know what we are testing against, there are test vectors associated with each testbench, showing the expected outputs that will be compared against the actual outputs given by the code. To avoid redundancy, I am only attaching the top level lab1_cw test vectors testbench, as it covers what is included in the testbenches of both submodules. The testbenches for my other modules can be found in my Lab 1 GitHub Repo\nBelow are the test vectors I used for the lab1_cw_testbench:\n// lab1_cw_testvectors.tv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// Test vectors to use in my testbench file, lab1_cw_testbench.sv, \n// to simulate LED and 7 segment display\n\n// Test vector format:\n// s[3:0]_LED[1:0]_seg[6:0]\n// led[2] is excluded because it blinks at 2.4 Hz, so it will be tested on an oscilloscope\n\n0000_00_1000000\n0001_01_1111001\n0010_01_0100100\n0011_00_0110000\n0100_00_0011001\n0101_01_0010010\n0110_01_0000010\n0111_00_1111000\n1000_00_0000000\n1001_01_0010000\n1010_01_0001000\n1011_00_0000011\n1100_10_1000110\n1101_11_0100001\n1110_11_0000110\n1111_10_0001110\nBelow is the code for the testbench used for lab1_cw:\n// lab1_cw_testbench.sv\n// Christian Wu\n// chrwu@g.hmc.edu\n// 08/31/25\n\n// This is a testbench to test my lab 1 code (lab1_cw.sv).\n// It tests the LED logic and 7-segment display logic based on different 4-bit inputs.\n\n`timescale 1ns/1ns\n`default_nettype none\n`define N_TV 16\n\nmodule lab1_cw_testbench();\n\nlogic clk;\nlogic reset;\n\nlogic [3:0] s;\nlogic [2:0] led;\nlogic [1:0] led_expected;\nlogic [6:0] seg, seg_expected;\nlogic [31:0] vectornum, errors;\nlogic [12:0] testvectors[10000:0]; // s[3:0]_led[1:0]_seg[6:0]\n\n// Instantiate the device under test (DUT)\nlab1_cw dut (.s(s), .led(led), .seg(seg));\n\n// generate clock\nalways begin\n    clk = 1; #5; clk = 0; #5;\nend\n\n// Load test vectors, and pulse reset\ninitial begin\n    $readmemb(\"lab1_cw_testvectors.tv\", testvectors, 0, `N_TV-1);\n    vectornum = 0; errors = 0;\n    reset = 1; #27; reset = 0;\nend\n\n// Apply test vectors at rising edge of clock\nalways @(posedge clk) begin\n    #1; {s, led_expected, seg_expected} = testvectors[vectornum];\nend\ninitial\nbegin\n    // Create dumpfile for signals\n    $dumpfile(\"lab1_cw_testbench.vcd\");\n    $dumpvars(0, lab1_cw_testbench);\nend\n\n// Check results on falling edge of clock\nalways @(negedge clk) begin\n    if (~reset) begin\n        if (led[1:0] != led_expected || seg != seg_expected) begin\n            $display(\"Error at vector %0d: s=%b, led=%b (expected %b), seg=%b (expected %b)\", \n                     vectornum, s, led[1:0], led_expected, seg, seg_expected);\n            errors = errors + 1;\n        end\n        vectornum = vectornum + 1;\n        if (vectornum &gt;= `N_TV) begin\n            $display(\"%0d tests completed with %0d errors\", vectornum, errors);\n            $stop;\n        end\n    end\nend\nendmodule\nSomething that I had trouble with on this testbench was getting it to output the message that says the tests completed with 0 errors. When I used if (testvectors[vectornum] === 13'bx) to stop the simulation and display the message, no message would display. Thus, I checked whether vectornum reached the number of test vectors I had and would stop the simulation. This method worked, however, I want to figure out why the other method would not work.\n\n\nTestbench Results\nI was able to simulate each of my modules in Questa and it successfully worked, meaning that the outputs of my modules matched the expected output depicted by my test vectors. Below are the waveforms for each of my module’s testbenches.\n\nlab1_ledController_testbench results (only testing led[1] and led[0]):\n\n\n\nlab1_ledController Waveforms\n\n\n\n\n\nlab1_ledController Transcript\n\n\nIn addition to the testbench for the LEDs, I also used an oscilloscope to confirm that led[2] is blinking at 2.4 Hz. The oscilloscope trace can be seen below:\n\n\n\nOscilloscope trace showing led[2] blinking at 2.4 Hz\n\n\n\n\nlab1_sevenSegmentDisplay_testbench results:\n\n\n\nlab1_sevenSegmentDisplay Waveforms\n\n\n\n\n\nlab1_sevenSegmentDisplay Transcript\n\n\n\n\nlab1_cw_testbench results (top level module including LED and 7-segment display output):\n\n\n\nlab1_cw Waveforms\n\n\n\n\n\nlab1_cw Transcript\n\n\nThus, all testbenches and testing for this lab was successful!\n\n\n\n\nHardware\n\nDesign and Schematic\nAfter finishing with testing, I can now build my hardware and program my FPGA. Below, is a table of all of my pin assignments, as well as my schematic:\n\nPin assignments for Lab 1 inputs and outputs\n\n\nName\nPin\n\n\n\n\ns[0]\n37\n\n\ns[1]\n31\n\n\ns[2]\n35\n\n\ns[3]\n32\n\n\nled[0]\n28\n\n\nled[1]\n38\n\n\nled[2]\n42\n\n\nseg[0]\n10\n\n\nseg[1]\n20\n\n\nseg[2]\n13\n\n\nseg[3]\n9\n\n\nseg[4]\n6\n\n\nseg[5]\n45\n\n\nseg[6]\n47\n\n\n\n\n\n\nLab 1 Schematic\n\n\nFor the 7-segment display, resistors were added at each of the seven segment pins to prevent the display from drawing too much current. After referencing the HDSP-511A Seven Segment Display Datasheet, I found that the forward voltage for the display is 2 V. Given that we are using a 3.3 V source voltage from the FPGA, the voltage across the resistor is 1.3 V. It is safe for the 7-segment display’s pins to be around 10-20 mA, so to keep it clean, I used 100 Ohm Resistors, giving a current of 13 mA.\n\n\nResults\nAfter finishing with the design, I was able to wire my board according to the schematic and programming my top level module, lab1_cw, onto my board. Since the lab ran out of ribbon cables, I used female to male jumper cables to connect my FPGA from the development board to my breadboard. I was able to physically verify that everything worked as expected. I used the oscilloscope to confirm that led[2] was blinking at 2.4 Hz, and the 7-segment display was able to display all 16 hexadecimal inputs. led[1:0] were also able to light up as expected based on the inputs s[3:0].\nBelow are pictures demonstrating all 16 hexadecimal values on my 7-segment display:\n\n\n\n\n\n\n7-Segment Display showing 1’h0\n\n\n\n\n\n\n\n7-Segment Display showing 1’h1\n\n\n\n\n\n\n\n7-Segment Display showing 1’h2\n\n\n\n\n\n\n\n7-Segment Display showing 1’h3\n\n\n\n\n\n\n\n\n\n7-Segment Display showing 1’h4\n\n\n\n\n\n\n\n7-Segment Display showing 1’h5\n\n\n\n\n\n\n\n7-Segment Display showing 1’h6\n\n\n\n\n\n\n\n7-Segment Display showing 1’h7\n\n\n\n\n\n\n\n\n\n7-Segment Display showing 1’h8\n\n\n\n\n\n\n\n7-Segment Display showing 1’h9\n\n\n\n\n\n\n\n7-Segment Display showing 1’hA\n\n\n\n\n\n\n\n7-Segment Display showing 1’hb\n\n\n\n\n\n\n\n\n\n7-Segment Display showing 1’hC\n\n\n\n\n\n\n\n7-Segment Display showing 1’hd\n\n\n\n\n\n\n\n7-Segment Display showing 1’hE\n\n\n\n\n\n\n\n7-Segment Display showing 1’hF\n\n\n\n\n\nBelow is a picture demonstrating led[1] being on when s[3] and s[2] is on, and led[0] being on with only s[1] being on.\n\n\n\nPicture showing led[1] and led[0] on based on s[3:0] inputs\n\n\nAs a result, my design and project has met all the requirements for this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrompt\nTo test how AI would do for this lab, I entered the following prompt to Claude AI:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\nAI Code\nAs a result, it returned the following code:\n// SystemVerilog LED Blinker for Lattice UP5K FPGA\n// Uses internal 48MHz oscillator to blink LED at 2Hz\n// Takes advantage of SystemVerilog features like logic, always_ff, etc.\n\nmodule led_blinker_up5k (\n    output logic led\n);\n\n    // Internal oscillator clock signal\n    logic clk_48mhz;\n    \n    // Counter for frequency division\n    // Need to divide 48MHz by 12M to get 4Hz toggle (2Hz blink)\n    // 12M = 12_000_000 requires 24 bits (2^24 = 16,777,216)\n    localparam int COUNTER_MAX = 12_000_000 - 1;\n    logic [23:0] counter;\n    \n    // LED output register\n    logic led_reg;\n    \n    // Instantiate the internal high-frequency oscillator\n    // SB_HFOSC is the Lattice UP5K primitive for the internal oscillator\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // 48MHz (divide by 1)\n    ) hfosc_inst (\n        .CLKHFPU(1'b1),     // Power up the oscillator\n        .CLKHFEN(1'b1),     // Enable the oscillator\n        .CLKHF(clk_48mhz)   // 48MHz clock output\n    );\n    \n    // Counter logic using SystemVerilog always_ff\n    always_ff @(posedge clk_48mhz) begin\n        if (counter &gt;= COUNTER_MAX) begin\n            counter &lt;= '0;\n            led_reg &lt;= ~led_reg;  // Toggle LED every 0.25 seconds\n        end else begin\n            counter &lt;= counter + 1'b1;\n        end\n    end\n    \n    // Assign LED output\n    assign led = led_reg;\n\nendmodule\n\n\nTest in Radiant\nI then started a new project in Radiant and attempted to synthesize the code. It was unable to synthesize due to the following error:\nERROR &lt;35901063&gt; - c:/users/chris/onedrive/desktop/wu-e155-lab1/lab1_cw_aiprototype/source/impl_1/led_blinker_up5k.sv(29): instantiating unknown module SB_HFOSC. VERI-1063\n\nchild process exited abnormally\nDone: error code 1\nClaude AI proceded to make some changes but after synthesizing, it still returned the same error.\n\n\nReflection\nAfter comparing my code to the one that Claude produced, I was able to see the potential of coding with AI. Claude got everything in the module correct with the exception of the HSOSC part. Although this is the most important part and Claude got it wrong, it was very close to being right, and small tweaks and guidance in the right direction on to properly use the HSOSC library would result in code that would work.\nI like how clean the syntax of Claude is, and the variable names are informative. The added comments are also quite helpful to understand the logic and structure of the code. With some support on the library, coding with an AI can be very powerful, as it is able to do the bulk of the work for us quickly and efficiently. Small tweaks for more nuanced things like specific libraries is a reasonable fix for me and an easy one to do, to be able to take advantage of the power of AI for the rest of the code. To do this, I could either change the code manually, or create more specific prompts to tell it how to use the library in a way that will work.\nOverall, I am very impressed with how well it worked, and I see a lot of potential for it to be used for the final project."
  },
  {
    "objectID": "labs/lab1/lab1.html#hours-spent",
    "href": "labs/lab1/lab1.html#hours-spent",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Hours Spent",
    "text": "Hours Spent\nI spent 24 hours on this lab."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Semester Goals for E155",
    "section": "",
    "text": "I took this course for a few reasons. First, I think that Hardware Engineering is a future career path for me, and something that I want to pursue long term. It is a good intersection between challenging problem solving that can impact billions of people around the world and my passion for electronics and computing. When I took E85 last year with Prof. Harris, I really enjoyed working on the labs, while sometimes challenging, it was really rewarding to see a project of mine come to fruition. I’ve chosen to take this course in my Junior year, in hopes that it will open up opportunities for internships in Hardware Engineeering. I would like to use my last summer of internships to be able to decide what career I would like to pursue after graduating from Mudd next year.\nThis semester, I would like to be able to absorb as much knowledge as I can, learning new techniques and ways to deal with software and hwardware. I think the nature of this class and the difficulty associated with it will also push me to learn some intangible skills that can be applied in my post-Mudd life. The tenacity and perseverance through challenging labs that aren’t going my way, and the ability to work more efficiently and under a time constraint to complete the labs on time every week will be valuable to being able to meet deadlines and tackle challenging real world problems in the industry.\nI look forward to a great semester of learning!"
  }
]