---
title: 'Lab 2: Multiplexed Seven Segment Display'
author: 'Christian Wu'
date: '09/07/25'
format:
    html:
        code-links:
         - text: "Lab 2 Github Repo"
           href: https://github.com/chrwu17/e155-lab2
           icon: github
        other-links:
         - text: "E155 Course Website: Lab 2"
           href: "https://hmc-e155.github.io/lab/lab2/"
---

## Introduction
The goal of this lab is to implement a time-multiplexer to drive two seven segment displays with a single set of FPGA I/O pins, using a transistor circuit to drive large currents from our FPGA to our dual seven-segment display, to output the hexadecimal numbers of two dip switches. There will also be five LEDs on the breadboard, which will display the sum of the two input values. 

## FPGA Design

### Objective
The objective of this lab is to use System Verilog to code a time-multiplexer to run both halves of my dual seven-segment display by oscillating between turning on the common anode of each display so that the naked eye cannot see the flickering of the two displays. To be able to supply the large current needed by the display, [2N3906 PNP transistors](https://www.onsemi.com/pdf/datasheet/2n3906-d.pdf) will be used. We will also use an adder to sum the two hexadecimal inputs from our dip switches and display that on five LEDs. 

### Design

#### Block Diagram
My approach to this lab consists on three different modules. An overarching top level module called `lab1_cw`, which will be programmed to the board, and two submodules `lab1_ledController`, and `lab1_sevenSegmentDisplay`. The `lab1_ledController` submodule will control the output of each LED, utilizing the HSOSC library to control `led[2]`, and utilizing simple logic to control `led[1:0]`. The `lab1_sevenSegmentDisplay` submodule will control the outputs on the 7-segment display, displaying the hexadecimal value provided by the dip switches, `s[3:0]`. The `lab1_cw` module will call both the `lab1_ledController` submodule and the `lab1_sevenSegmentDisplay` submodule to run on the board. Below is the block diagram I used to create this project:

![Lab 1 Block Diagram](images/blockDiagram.jpeg)

#### LED Design
Design for the `lab1_ledController` submodule was split into two components, designing the logic for `led[1:0]` based on inputs `s[3:0]`, and making `led[2]` blink at 2.4 Hz. 

Designing the logic for `led[1:0]` was fairly simple, based on the patterns formed from the table above. Inputs `s1` and `s0` control the output of `led[0]`. From the table, `led[0]` is formed by an XOR gate with inputs `s1` and `s0`. 

Inputs `s3` and `s2` control the output of `led[1]`. From the table, `led[1]` is formed by an AND gate, with inputs `s3` and `s2`. 

Designing `led[2]` to blink at 2.4 Hz was a bit more challenging. To run at 2.4 Hz, every full cycle of the LED should be around 0.4167 seconds per cycle. Given that the LED is on or off for only half a cycle, which is also known as a 50% duty cycle, the LED needs to change state every half cycle, or every 0.2083 seconds. The HSOSC oscillator runs at 48 MHz. So in order for us to change states at every 0.2083 seconds, the clock will need to tick 10,000,000 times. This is done using a counter, which at every 10 million clock ticks of the HSOSC oscillator, will change the state of the LED from on to off or vice versa. 

Below is the code block that was used for this submodule:

```markdown
// lab1_ledController.sv
// Christian Wu
// chrwu@g.hmc.edu
// 08/31/25

// This module takes in a 4-bit input 's', using the dip switches on the motherboard,
// and controls a 3-bit LED output led[2:0], which are the SMD LEDs on the motherboard.

module lab1_ledController (
    input logic [3:0] s,
    output logic [2:0] led
);

// LED Logic for led[0] and led[1]
    xor led0_logic(led[0], s[0], s[1]);
    and led1_logic(led[1], s[2], s[3]);

    // LED Logic for led[2] to blink at 2.4 Hz
    logic int_osc;
	logic led_state = 0;
	logic [24:0] counter = 0;
	
	// Internal high-speed oscillator
	HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));
	
	// Simple clock divider
	always_ff @(posedge int_osc)
		begin
			counter <= counter + 1;
            if (counter == 10_000_000) begin // Adjust this value for 2.4 Hz
                led_state <= ~led_state;
                counter <= 0;
            end
		end
    //assign led[2] to blink state    
    assign led[2] = led_state;

endmodule
```

#### Seven Segment Display Design
Designing the `lab1_sevenSegmentDisplay` submodule was fairly simple. It involved using a case statement to write out the outputs, `seg[6:0]` of the 7-segment display for all 16 possible inputs of `s[3:0]`. While writing the code, it is worth noting that turning on each segment of the 7-segment display was with a `0` output as the cathode is connected to each output pin. 

Below is a labeled image of each segment of the 7-segment display and the code for this submodule, where `s[0]` is segment A and `s[6]` is segment G of the 7-segment display:

![7-segment display segment mapping](images/seven_seg_map.png){width=25%}

```markdown
// lab1_sevenSegmentDisplay.sv
// Christian Wu
// chrwu@g.hmc.edu
// 08/31/25

// This module takes in a 4-bit input 's', using the dip switches on the motherboard,
// and controls the seven-segment display output seg[6:0].
module lab1_sevenSegmentDisplay (
    input logic [3:0] s,
    output logic [6:0] seg);
 // 7-Segment Display Logic
    always_comb begin
        case (s)
            4'h0: seg = 7'b1000000; // 0
            4'h1: seg = 7'b1111001; // 1
            4'h2: seg = 7'b0100100; // 2
            4'h3: seg = 7'b0110000; // 3
            4'h4: seg = 7'b0011001; // 4
            4'h5: seg = 7'b0010010; // 5
            4'h6: seg = 7'b0000010; // 6
            4'h7: seg = 7'b1111000; // 7
            4'h8: seg = 7'b0000000; // 8
            4'h9: seg = 7'b0010000; // 9
            4'hA: seg = 7'b0001000; // A
            4'hB: seg = 7'b0000011; // b
            4'hC: seg = 7'b1000110; // C
            4'hD: seg = 7'b0100001; // d
            4'hE: seg = 7'b0000110; // E
            4'hF: seg = 7'b0001110; // F
            default: seg = 7'b1111111; // Off
        endcase
    end
endmodule
```

#### Top Level Module
Given that this lab project was split into one top level module and two submodules, the top level module is quite simple. It is a module that calls upon the two submodules, `lab1_ledController` and `lab1_sevenSegmentDisplay`. This top level module, `lab1_cw`, will then be programmed onto the FPGA. 

Below is the code for the top level module, `lab1_cw`:

```markdown
// lab1_cw.sv
// Christian Wu
// chrwu@g.hmc.edu
// 08/31/25

// This module takes in a 4-bit input 's', using the dip switches on the motherboard,  
// and controls a 3-bit LED output led[2:0], which are the SMD LEDs on the motherboard, 
// and a 7-segment display output seg[6:0].
module lab1_cw (
    input logic [3:0] s,
    output logic [2:0] led,
    output logic [6:0] seg
);
    // call led controller module
    lab1_ledController led_ctrl (.s(s), .led(led));
    // call seven segment display module
    lab1_sevenSegmentDisplay seg_ctrl (.s(s), .seg(seg));

endmodule
```

### Testbench Simulation and Testing

#### Testbench and Test Vector Design
To test my code and see whether it would work as expected, I created a testbench to test before moving on to using physical hardware. I created a testbench of each of my three modules. For the top level module, `lab1_cw`, I tested that the LED and 7-segment display outputs would be correct based on the dip switch input. For the `lab1_ledController` submodule, I tested just the LED outputs with the dip switch input. For the `lab1_sevenSegmentDisplay` submodule, I tested just the 7-segment display output with the dip switch input. For both the `lab1_cw` module and the `lab1_ledController` submodule, I omitted `led[2]` from the testbench and test vectors as it is blinking at 2.4 Hz. 

To know what we are testing against, there are test vectors associated with each testbench, showing the expected outputs that will be compared against the actual outputs given by the code. To avoid redundancy, I am only attaching the top level `lab1_cw` test vectors testbench, as it covers what is included in the testbenches of both submodules. The testbenches for my other modules can be found in my [Lab 1 GitHub Repo](https://github.com/chrwu17/e155-lab1/tree/main/fpga/sim)

Below are the test vectors I used for the `lab1_cw_testbench`:

```markdown
// lab1_cw_testvectors.tv
// Christian Wu
// chrwu@g.hmc.edu
// 08/31/25

// Test vectors to use in my testbench file, lab1_cw_testbench.sv, 
// to simulate LED and 7 segment display

// Test vector format:
// s[3:0]_LED[1:0]_seg[6:0]
// led[2] is excluded because it blinks at 2.4 Hz, so it will be tested on an oscilloscope

0000_00_1000000
0001_01_1111001
0010_01_0100100
0011_00_0110000
0100_00_0011001
0101_01_0010010
0110_01_0000010
0111_00_1111000
1000_00_0000000
1001_01_0010000
1010_01_0001000
1011_00_0000011
1100_10_1000110
1101_11_0100001
1110_11_0000110
1111_10_0001110
```

Below is the code for the testbench used for `lab1_cw`:

```markdown
// lab1_cw_testbench.sv
// Christian Wu
// chrwu@g.hmc.edu
// 08/31/25

// This is a testbench to test my lab 1 code (lab1_cw.sv).
// It tests the LED logic and 7-segment display logic based on different 4-bit inputs.

`timescale 1ns/1ns
`default_nettype none
`define N_TV 16

module lab1_cw_testbench();

logic clk;
logic reset;

logic [3:0] s;
logic [2:0] led;
logic [1:0] led_expected;
logic [6:0] seg, seg_expected;
logic [31:0] vectornum, errors;
logic [12:0] testvectors[10000:0]; // s[3:0]_led[1:0]_seg[6:0]

// Instantiate the device under test (DUT)
lab1_cw dut (.s(s), .led(led), .seg(seg));

// generate clock
always begin
    clk = 1; #5; clk = 0; #5;
end

// Load test vectors, and pulse reset
initial begin
    $readmemb("lab1_cw_testvectors.tv", testvectors, 0, `N_TV-1);
    vectornum = 0; errors = 0;
    reset = 1; #27; reset = 0;
end

// Apply test vectors at rising edge of clock
always @(posedge clk) begin
    #1; {s, led_expected, seg_expected} = testvectors[vectornum];
end
initial
begin
    // Create dumpfile for signals
    $dumpfile("lab1_cw_testbench.vcd");
    $dumpvars(0, lab1_cw_testbench);
end

// Check results on falling edge of clock
always @(negedge clk) begin
    if (~reset) begin
        if (led[1:0] != led_expected || seg != seg_expected) begin
            $display("Error at vector %0d: s=%b, led=%b (expected %b), seg=%b (expected %b)", 
                     vectornum, s, led[1:0], led_expected, seg, seg_expected);
            errors = errors + 1;
        end
        vectornum = vectornum + 1;
        if (vectornum >= `N_TV) begin
            $display("%0d tests completed with %0d errors", vectornum, errors);
            $stop;
        end
    end
end
endmodule
```

Something that I had trouble with on this testbench was getting it to output the message that says the tests completed with 0 errors. When I used `if (testvectors[vectornum] === 13'bx)` to stop the simulation and display the message, no message would display. Thus, I checked whether `vectornum` reached the number of test vectors I had and would stop the simulation. This method worked, however, I want to figure out why the other method would not work. 

#### Testbench Results
I was able to simulate each of my modules in Questa and it successfully worked, meaning that the outputs of my modules matched the expected output depicted by my test vectors. Below are the waveforms for each of my module's testbenches. 


##### `lab1_ledController_testbench` results (only testing `led[1]` and `led[0]`):

![`lab1_ledController` Waveforms](images/ledController_WaveForms.PNG)

![`lab1_ledController` Transcript](images/ledController_Transcript.PNG)

In addition to the testbench for the LEDs, I also used an oscilloscope to confirm that `led[2]` is blinking at 2.4 Hz. The oscilloscope trace can be seen below:

![Oscilloscope trace showing `led[2]` blinking at 2.4 Hz](images/oscilloscope.JPG)

##### `lab1_sevenSegmentDisplay_testbench` results:

![`lab1_sevenSegmentDisplay` Waveforms](images/sevenSegmentDisplay_Waveforms.PNG)

![`lab1_sevenSegmentDisplay` Transcript](images/sevenSegmentDisplay_Transcript.PNG)

##### `lab1_cw_testbench` results (top level module including LED and 7-segment display output):

![`lab1_cw` Waveforms](images/lab1_cw_Waveforms.PNG)

![`lab1_cw` Transcript](images/lab1_cw_Transcript.PNG)

Thus, all testbenches and testing for this lab was successful!

### Hardware

#### Design and Schematic
After finishing with testing, I can now build my hardware and program my FPGA. Below, is a table of all of my pin assignments, as well as my schematic:

| Name    | Pin   |
|---------|:------|
| s[0]    |   37  |   
| s[1]    |   31  |  
| s[2]    |   35  |
| s[3]    |   32  |  
| led[0]  |   28  |   
| led[1]  |   38  |  
| led[2]  |   42  | 
| seg[0]  |   10  |  
| seg[1]  |   20  |
| seg[2]  |   13  |  
| seg[3]  |   9   |
| seg[4]  |   6   |  
| seg[5]  |   45  |
| seg[6]  |   47  |

: Pin assignments for Lab 1 inputs and outputs

![Lab 1 Schematic](images/schematic.jpeg)

For the 7-segment display, resistors were added at each of the seven segment pins to prevent the display from drawing too much current. After referencing the [HDSP-511A Seven Segment Display Datasheet](https://docs.broadcom.com/doc/AV02-1363EN), I found that the forward voltage for the display is 2 V. Given that we are using a 3.3 V source voltage from the FPGA, the voltage across the resistor is 1.3 V. It is safe for the 7-segment display's pins to be around 10-20 mA, so to keep it clean, I used 100 Ohm Resistors, giving a current of 13 mA. 

#### Results
After finishing with the design, I was able to wire my board according to the schematic and programming my top level module, `lab1_cw`, onto my board. Since the lab ran out of ribbon cables, I used female to male jumper cables to connect my FPGA from the development board to my breadboard. I was able to physically verify that everything worked as expected. I used the oscilloscope to confirm that `led[2]` was blinking at 2.4 Hz, and the 7-segment display was able to display all 16 hexadecimal inputs. `led[1:0]` were also able to light up as expected based on the inputs `s[3:0]`. 

Below are pictures demonstrating all 16 hexadecimal values on my 7-segment display: 

::: {layout-ncol="4"}
![7-Segment Display showing 1'h0](images/1h0.JPG)

![7-Segment Display showing 1'h1](images/1h1.JPG)

![7-Segment Display showing 1'h2](images/1h2.JPG)

![7-Segment Display showing 1'h3](images/1h3.JPG)

![7-Segment Display showing 1'h4](images/1h4.JPG)

![7-Segment Display showing 1'h5](images/1h5.JPG)

![7-Segment Display showing 1'h6](images/1h6.JPG)

![7-Segment Display showing 1'h7](images/1h7.JPG)

![7-Segment Display showing 1'h8](images/1h8.JPG)

![7-Segment Display showing 1'h9](images/1h9.JPG)

![7-Segment Display showing 1'hA](images/1ha.JPG)

![7-Segment Display showing 1'hb](images/1hb.JPG)

![7-Segment Display showing 1'hC](images/1hc.JPG)

![7-Segment Display showing 1'hd](images/1hd.JPG)

![7-Segment Display showing 1'hE](images/1he.JPG)

![7-Segment Display showing 1'hF](images/1hf.JPG)
:::

Below is a picture demonstrating `led[1]` being on when `s[3]` and `s[2]` is on, and `led[0]` being on with only `s[1]` being on. 

![Picture showing `led[1]` and `led[0]` on based on `s[3:0]` inputs](images/ledDemo.JPG)

As a result, my design and project has met all the requirements for this lab. 

## AI Prototype

### Prompt
To test how AI would do for this lab, I entered the following prompt to Claude AI:

```markdown
Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.
```
### AI Code
As a result, it returned the following code:

```markdown
// SystemVerilog LED Blinker for Lattice UP5K FPGA
// Uses internal 48MHz oscillator to blink LED at 2Hz
// Takes advantage of SystemVerilog features like logic, always_ff, etc.

module led_blinker_up5k (
    output logic led
);

    // Internal oscillator clock signal
    logic clk_48mhz;
    
    // Counter for frequency division
    // Need to divide 48MHz by 12M to get 4Hz toggle (2Hz blink)
    // 12M = 12_000_000 requires 24 bits (2^24 = 16,777,216)
    localparam int COUNTER_MAX = 12_000_000 - 1;
    logic [23:0] counter;
    
    // LED output register
    logic led_reg;
    
    // Instantiate the internal high-frequency oscillator
    // SB_HFOSC is the Lattice UP5K primitive for the internal oscillator
    SB_HFOSC #(
        .CLKHF_DIV("0b00")  // 48MHz (divide by 1)
    ) hfosc_inst (
        .CLKHFPU(1'b1),     // Power up the oscillator
        .CLKHFEN(1'b1),     // Enable the oscillator
        .CLKHF(clk_48mhz)   // 48MHz clock output
    );
    
    // Counter logic using SystemVerilog always_ff
    always_ff @(posedge clk_48mhz) begin
        if (counter >= COUNTER_MAX) begin
            counter <= '0;
            led_reg <= ~led_reg;  // Toggle LED every 0.25 seconds
        end else begin
            counter <= counter + 1'b1;
        end
    end
    
    // Assign LED output
    assign led = led_reg;

endmodule
```

### Test in Radiant
I then started a new project in Radiant and attempted to synthesize the code. It was unable to synthesize due to the following error:

```markdown
ERROR <35901063> - c:/users/chris/onedrive/desktop/wu-e155-lab1/lab1_cw_aiprototype/source/impl_1/led_blinker_up5k.sv(29): instantiating unknown module SB_HFOSC. VERI-1063

child process exited abnormally
Done: error code 1
```

Claude AI proceded to make some changes but after synthesizing, it still returned the same error. 

### Reflection
After comparing my code to the one that Claude produced, I was able to see the potential of coding with AI. Claude got everything in the module correct with the exception of the HSOSC part. Although this is the most important part and Claude got it wrong, it was very close to being right, and small tweaks and guidance in the right direction on to properly use the HSOSC library would result in code that would work. 

I like how clean the syntax of Claude is, and the variable names are informative. The added comments are also quite helpful to understand the logic and structure of the code. With some support on the library, coding with an AI can be very powerful, as it is able to do the bulk of the work for us quickly and efficiently. Small tweaks for more nuanced things like specific libraries is a reasonable fix for me and an easy one to do, to be able to take advantage of the power of AI for the rest of the code. To do this, I could either change the code manually, or create more specific prompts to tell it how to use the library in a way that will work. 

Overall, I am very impressed with how well it worked, and I see a lot of potential for it to be used for the final project. 

## Hours Spent
I spent 24 hours on this lab.